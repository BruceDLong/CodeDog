/-####### Native CodeDog library

requirements = [
    [require, CodeDog_implementation]
]

struct GLOBAL{
    const double: pi <- 3.1415926535897

    me string: dispBool(me bool: tf) <- {
        if(tf){return("true")} else {return("false")}
    }

    /- Convert doubles to strings w/ a specified number of significant figures. (Pretty axes labels)
    /- TODO: Rounding, trailing 0's, leading 0's, track decimal point, tolerance range test, clean integers, move label w/ high sigfigs
    me string: dblToString(me double: val, me int: sigFigs) <- {
        me string: S <- toString(val)
        me string: S2 <- ""
        me int: sizeS <- S.size()
        me int: sizeS2 <- 0
        me int: digits <- 0
        me char: S2last
        me bool: hasDecimal <- false

        /- Limit sig figs to length of double minus possible "." and "-"
        if(sizeS < sigFigs) {sigFigs <- sizeS-2}

        /- Zero is 0
        if(val==0) {return(" 0")}

        withEach Pos in RANGE(0..sizeS) {
            me char: ch <- S[Pos]
            if(ch != "." and ch != "-") {
                digits <- digits + 1
                /-print("digits is ", digits, ". Pos is ", Pos, ". S is ", S, "\n")
                if(digits >= sigFigs+1 and hasDecimal == true) {
                    S2 <- S.subStr(0, Pos)
                    break()
                }
            } else if(ch == ".") {hasDecimal <- true}
        }

        /- Trim trailing period
        sizeS2 <- S2.size()
        S2last <- S2[sizeS2-1]
        if(S2last == ".") { S2 <- S2.subStr(0, sizeS2-1) }

        return(S2)
    }

    me string: dispFieldAsText(me string: label, me int:labelLen) <- {
        me string: S <- ""
        me int: labelSize<-label.size()
        withEach count in RANGE(0..labelLen){
            if (count<labelSize){S <- S+label[count]}
            else if(count==labelSize){ S <- S+":"}
            else {S <- S+" "}
        }
        return(S)
    }
}

struct sessionFile{
    me FileStream: session
    me void: openSession(me string: filename) <-{session.openAppend(filename)}
    me void: closeSession() <- {session.close()}
    me void: writeEntry(me string: entry) <- {entry<-entry+"\n"; session.write(entry)}

    me bool: openToRead(me string: filename) <- {
        session.open(filename)
        if(session.failure()){print("Creating session file "+filename+"\n"); return(true)}
        return(false)
    }
    me string: readEntry() <- {me string: retVal; session.getLine(retVal); return(retVal)}
    me bool: eof() <- {return(session.EOF())}
    me void: closeReading() <- {session.close()}
}

struct stringScanner{
    me string: S
    me int: pos
    void: initialize(me string: str) <- {S<-str  reset()}
    void: reset() <- {pos<-0}

    me int: skipWS() <- {       /- Skip past 0 or more whitespace characters.  Return the new pos
        me char: ch
        me int: txtSize <- S.size()
        withEach p in RANGE(pos .. txtSize){
            ch <- S[p]
            if(! isspace(ch) or p==txtSize){pos<-p break()}
        }
        return(pos)
    }

    me int: skipPast(me string: findStr) <- {       /- Skip past <txt>.  Return pos or -1 if End-of-string reached
        me int: txtSize <- S.size()
        me int: fs <- findStr.size()
        withEach p in RANGE(pos .. txtSize){
            withEach i in RANGE(0 .. fs){
                /-print(">> fs/p/i:", fs, " ", p, " ", i, ", findStr[i]:", findStr[i], " S[p+i]:", S[p+i], "\n")
                if( findStr[i] != S[p+i]) {
                    break()
                } else {if(i==(fs-1)) {pos <- p+fs return(pos)}}
            }
        }
        return(-1)
    }

    me int: skipTo(me string: findStr) <- {       /- Skip up to <txt>.  Return pos or -1 if End-of-string reached
        me int: foundPos <- skipPast(findStr)
        if(foundPos > 0) {return(foundPos-findStr.size())}
        else {return(-1)}
    }

    me int: chkStr(me string: s) <- {
        me int: L <- s.size()
        if(pos+L > S.size()){return(-1)}
        withEach i in RANGE(0 .. L){
            if( s[i] != S[pos+i]) {
                return(-1)
            }
        }
        pos <- pos+L
        return(pos)
    }
}
