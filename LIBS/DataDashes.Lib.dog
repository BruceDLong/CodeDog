/- CodeDog graph dash for DashBoard

featuresNeeded = [Dashboard]

/- //// GRAPH SCALES
struct graphScale: inherits=dash{
    me bool:      isVisible
    me int:       ticksPerStep
    me bool:      textSlant
    me bool:      isDate
    me timeValue: step
    me GUI_Scalar:    tickStep
    me GUI_Scalar:       yOrig
    me GUI_Scalar:       xOrig
    me timeValue: lowVal
    me timeValue: hiVal
    me GUI_Scalar:       span
    me int:       tickOffset
    const int:    tickPadding  <- 3
    const int:    titlePadding <- 7
    me int:       zoomLvl
    me timeValue: divisor

    void: initScale(me string: titleStr, me bool: IsVisible, me int: TicksPerStep,  me bool: TextSlant, me bool: IsDate) <- {
        title        <- titleStr
        isVisible    <- IsVisible
        ticksPerStep <- TicksPerStep
        textSlant    <- TextSlant
        isDate       <- IsDate
    }
}

struct verticalScale: inherits=graphScale{
    void: draw(me GUI_ctxt: cr) <- {
        me GUI_Scalar:    XPoint  <- 0
        me GUI_Scalar:    YPoint  <- 0
        me deltaSize: size
        me int:       labelWidth <- 0
        me string:    label
        me string:    justify <- ""

        /- AXIS VALUE LABELS
        withEach val in RANGE(0.. (hiVal-lowVal)/step+1){
            label <- dblToString(val*step+lowVal, 2)
            size <- getTextSize(cr, label, styler.fontSmall)
            YPoint <- yOrig-(val*step*span/(hiVal-lowVal)-size.height/3)
            if(textSlant){
            if (tickOffset > 0){XPoint <- xOrig+tickOffset+3*tickPadding+size.height/2}
            else               {XPoint <- xOrig+tickOffset-3*tickPadding; justify <- "right"}
            size <- renderTextRotate(cr, label, styler.fontSmall, XPoint, YPoint, -45, justify)
            }else{
            if (tickOffset > 0){XPoint <- xOrig+tickOffset+3*tickPadding}
            else               {XPoint <- xOrig+tickOffset-3*tickPadding-size.width}
            renderText(cr, label, styler.fontSmall, XPoint, YPoint)
            }
            if(size.width > labelWidth){labelWidth <- size.width}
        }

        /- AXIS TICK MARKS
        if(ticksPerStep>0){
            tickStep <- step/ticksPerStep
            cr.setLineWidth(1)
            withEach val in RANGE(0.. (hiVal-lowVal)/tickStep+1){
            if (tickOffset > 0){XPoint <- xOrig+3}
            else               {XPoint <- xOrig-3}
            YPoint <- yOrig - convertToGUIScalar(val)*tickStep*span/(hiVal-lowVal)
            cr.moveTo(XPoint, YPoint)
            cr.lineTo(XPoint+tickOffset, YPoint)
            }
            cr.strokeNow()
        }

        /- SCALE TITLE
        me int: degree
        if (tickOffset > 0){XPoint <- xOrig+labelWidth+tickOffset+3*tickPadding+titlePadding; degree <- 90}
        else               {XPoint <- xOrig-labelWidth+tickOffset-3*tickPadding-titlePadding; degree <- -90}
        rotate(cr, XPoint, YPoint+span/2, degree)
        renderTextCentered(cr, title, styler.fontDefault, XPoint, YPoint+span/2)
        restore(cr)
        cr.strokeNow()
    }

    void: setScale(me GUI_Scalar: Span, me timeValue: LowVal, me timeValue: HiVal, me int: Step, me GUI_Scalar: XOrig, me GUI_Scalar: YOrig, me int: TickOffset) <- {
        span         <- Span    /- length of axis (width or height of graph)
        lowVal       <- LowVal
        hiVal        <- HiVal
        step         <- Step
        xOrig        <- XOrig
        yOrig        <- YOrig
        tickOffset   <- TickOffset
    }
}

struct horizontalScale: inherits=graphScale{
    void: draw(me GUI_ctxt: cr) <- {
        me GUI_Scalar:     XPoint <- 0
        me GUI_Scalar:     YPoint <- 0
        me deltaSize:  size
        me int:        labelHeight <- 0
        me int:        tickHeight  <- 0
        me string:     label
        me string:     justify <- ""
        me sysLocale:  loc <- unicodeMgr.SetLocale("en")
        me timeValue:  firstTick
        me timeValue:  remainder

        remainder <- hiVal % divisor
        firstTick <- hiVal - remainder - step*((hiVal-lowVal)/step-1)
        me string: firstTickHr <- unicodeMgr.getHour(firstTick, loc)

        if (step >= 1000*60*60*24) {
            while(firstTickHr != "24") {
                remainder <- remainder + 1000*60*60
                firstTick <- hiVal - remainder - step*((hiVal-lowVal)/step-1)
                firstTickHr <- unicodeMgr.getHour(firstTick, loc)
            }
        }

        /- AXIS VALUE LABELS
        withEach val in RANGE(0.. (hiVal-lowVal)/step){
            if(isDate){label <- unicodeMgr.dateToIntlString(val*step+firstTick, hiVal-lowVal, loc)}
            else      {label <- dblToString(val*step+firstTick, 2)}
            size <- getTextSize(cr, title, styler.fontSmall)
            if (tickOffset > 0){tickHeight  <- tickOffset+3*tickPadding; YPoint <- yOrig+tickHeight+size.height}
            else               {tickHeight  <- tickOffset-3*tickPadding; YPoint <- yOrig+tickHeight}
            if(textSlant){
            if (tickOffset > 0){
                XPoint <- xOrig+val*step*span/(hiVal-lowVal)-5
                justify <- "right"
                YPoint <- YPoint - 10
            }
            else{XPoint <- xOrig+val*step*span/(hiVal-lowVal)}
            size <- renderTextRotate(cr, label, styler.fontSmall, XPoint, YPoint, -45, justify)
            }else{
            XPoint <- xOrig+(val*step + firstTick - lowVal)*span/(hiVal-lowVal)-5
            size <- renderTextCentered(cr, label, styler.fontSmall, XPoint, YPoint)
            }
            if(size.height > labelHeight){labelHeight <- size.height}
            cr.strokeNow()
        }

        /- AXIS TICK MARKS
        if(ticksPerStep>0){
            tickStep <- step/ticksPerStep
            cr.setLineWidth(1)
            withEach val in RANGE(0.. (hiVal-lowVal)/tickStep){
            if (tickOffset > 0){YPoint <- yOrig+tickPadding}
            else               {YPoint <- yOrig-tickPadding}
            XPoint <- xOrig + (val*tickStep + firstTick - lowVal)*span/(hiVal-lowVal)
            cr.moveTo(XPoint, YPoint)
            cr.lineTo(XPoint, YPoint+tickOffset)
            }
            cr.strokeNow()
        }

        /- SCALE TITLE
        size <- getTextSize(cr, title, styler.fontDefault)
        if(tickOffset > 0){YPoint <- yOrig+tickHeight+labelHeight+titlePadding+size.height}
        else              {YPoint <- yOrig+tickHeight-labelHeight-titlePadding}
        renderText(cr, title, styler.fontDefault, xOrig+span/2, YPoint)
        cr.strokeNow()
    }

    void: setScale(me GUI_Scalar: Span, me timeValue: LowVal, me timeValue: HiVal, me int: ZoomLvl, me GUI_Scalar: XOrig, me GUI_Scalar: YOrig, me int: TickOffset) <- {
        span         <- Span    /- length of axis (width or height of graph)
        lowVal       <- LowVal
        hiVal        <- HiVal
        zoomLvl      <- ZoomLvl
        xOrig        <- XOrig
        yOrig        <- YOrig
        tickOffset   <- TickOffset
    me timeValue: t0  <- 1000*12
    me timeValue: t1  <- 1000*60*12
    me timeValue: t2  <- 1000*60*60
    me timeValue: t3  <- 1000*60*60*2
    me timeValue: t4  <- 1000*60*60*4
    me timeValue: t5  <- 1000*60*60*24
    me timeValue: t6  <- 1000*60*60*24*2
    me timeValue: t7  <- 1000*60*60*24*5
    me timeValue: t8  <- 1000*60*60*24*10
    me timeValue: t9  <- 1000*60*60*24*15
    me timeValue: t10 <- 1000*60*60*12

        me timeValue[list]: stepTable    <- [t0,t1,t2,t3,t4, t5,t6,t7,t8,t9, 2592000000, 6307200000]
        me timeValue[list]: divisorTable <- [t0,t1,t2,t3,t4,t10,t6,t7,t8,t9, 2592000000, 6307200000]

        step    <- stepTable[zoomLvl]
        divisor <- divisorTable[zoomLvl]
    }
}
/- //// TOP BAR TOGGLES
struct circleButton: inherits=dash{
    me GUI_Scalar:    radius
    me string: symbol
    me double: stickLen

    me void: drawCircleBtn(me GUI_ctxt: cr) <- {
        if (symbol=="+") {
            cr.setLineWidth(1)
            cr.moveTo(posX + radius, posY + radius/4)
            cr.lineTo(posX + radius, posY + 7*radius/4)
            cr.strokeNow()
        }
        if (symbol=="+" or symbol=="-") {
            cr.setLineWidth(1)
            cr.moveTo(posX + radius/4, posY + radius)
            cr.lineTo(posX + 7*radius/4, posY + radius)
            cr.strokeNow()
        }
        if (symbol=="<") {
            cr.setLineWidth(1)
            cr.moveTo(posX + radius, posY + radius - stickLen * sqrt(2.0))
            cr.lineTo(posX + radius - stickLen * sqrt(2), posY + radius)
            cr.lineTo(posX + radius, posY + radius + stickLen * sqrt(2.0))
            cr.strokeNow()
        }
        if (symbol==">") {
            cr.setLineWidth(1)
            cr.moveTo(posX + radius, posY + radius - stickLen * sqrt(2.0))
            cr.lineTo(posX + radius + stickLen * sqrt(2), posY + radius)
            cr.lineTo(posX + radius, posY + radius + stickLen * sqrt(2.0))
            cr.strokeNow()
        }
        cr.circle(posX + radius, posY + radius, radius)
        cr.strokeNow()
    }

    me void: initCircleBtn(me GUI_Scalar: PosX, me GUI_Scalar: PosY, me GUI_Scalar: Radius, me string: Symbol) <- {
        posX   <- PosX
        posY   <- PosY
        radius <- Radius
        width  <- 2*radius
        height <- 2*radius
        symbol <- Symbol
        stickLen <- radius/3
    }

    /- Click functionality is inside graph clicks
    me bool: primaryDn(their GUI_ButtonEvent: event) <- {
        if (isTouchingMe(event.x, event.y)) {return(true)}
        else {return(false)}
    }
    me bool: primaryUp(their GUI_ButtonEvent: event) <- {
        if (isTouchingMe(event.x, event.y)) {return(true)}
        else {return(false)}
    }
}

struct zoomWidget: inherits=dash{
    me circleButton: zoomInBtn
    me circleButton: zoomOutBtn
    me string:       label
    me GUI_Scalar:          radius
    me GUI_Scalar:          labelX
    me int:          maxLabelLength

    void: draw(me GUI_ctxt: cr) <- {
        zoomOutBtn.initCircleBtn(posX, posY, radius, "-")
        zoomOutBtn.drawCircleBtn(cr)
        labelX <- posX + 3*radius
        renderTextCentered(cr, label, styler.fontSmall, labelX + maxLabelLength/2, posY + 3*radius/2)
        cr.strokeNow()
        zoomInBtn.initCircleBtn(labelX + maxLabelLength + radius, posY, radius, "+")
        zoomInBtn.drawCircleBtn(cr)
    }

    void: initZoomWidget(me GUI_Scalar: PosX, me GUI_Scalar: PosY, me string: Label, me GUI_Scalar: Radius, me int: MaxLabelLength) <- {
        posX  <- PosX
        posY  <- PosY
        label <- Label
        radius <- Radius
        maxLabelLength <- MaxLabelLength
    }
}

struct streamToggle: inherits=dash{
    me circleButton: left
    me circleButton: right
    me string[list]: dataStreamsTitleTbl
    me int: state
    me string: label
    me deltaSize: labelSize
    me int: radius
    me int: maxLabelLength
    me double: latest

    void: draw(me GUI_ctxt: cr) <- {
        if (state != 0) {
            renderTextCentered(cr, dblToString(latest, 0), styler.fontTitle, posX + 3*radius + maxLabelLength/2, posY + 45)
            renderTextCentered(cr, "Avg", styler.fontSmall, posX + 3*radius + maxLabelLength/2, posY + 45 + 15)
        }
        label <- dataStreamsTitleTbl[state]
        left.drawCircleBtn(cr)
        labelSize <- getTextSize(cr, label, styler.fontSmall)
        renderTextCentered(cr, label, styler.fontSmall, posX + 3*radius + maxLabelLength/2, posY + labelSize.height)
        right.drawCircleBtn(cr)
    }

    void: initStreamToggle(me GUI_Scalar: PosX, me GUI_Scalar: PosY, me string[list]: DataStreamsTitleTbl, me int: State) <- {
        posX <- PosX
        posY <- PosY
        radius <- 10
        maxLabelLength <- 75
        dataStreamsTitleTbl <- DataStreamsTitleTbl
        state <- State
        label <- dataStreamsTitleTbl[state]
        latest <- 0

        left.initCircleBtn(posX, posY, radius, "<")
        right.initCircleBtn(posX + 3*radius + maxLabelLength + radius, posY, radius, ">")
    }

    void: incrementStreamState(me int: Increment, me int: otherState) <- {
        if (state + Increment < 0) {state <- dataStreamsTitleTbl.size()-1}
        else if (state + Increment >= dataStreamsTitleTbl.size()) {state <- 0}
        else {state <- state + Increment}
        if (state == otherState) {incrementStreamState(Increment, otherState)}
    }

    /- Click functionality is inside graph clicks
    me bool: primaryDn(their GUI_ButtonEvent: event) <- {
        if (isTouchingMe(event.x, event.y)) {return(true)}
        else {return(false)}
    }
    me bool: primaryUp(their GUI_ButtonEvent: event) <- {
        if (isTouchingMe(event.x, event.y)) {return(true)}
        else {return(false)}
    }
}

struct graphTitleWidget: inherits=dash{
    me string: titleTxt
    me bool:   isVisible

    void: draw(me GUI_ctxt: cr, me GUI_Scalar: PosX, me GUI_Scalar: PosY) <- {
        posX     <- PosX
        posY     <- PosY
        renderTextCentered(cr, titleTxt, styler.fontTitle, posX, posY)
        cr.strokeNow()
    }

    void: initGraphTitle(me string: TitleTxt, me bool: IsVisible) <- {
        titleTxt  <- TitleTxt
        isVisible <- IsVisible
    }
}

struct timeStepInterval{their graph: parentWidget me timeValue: start me timeValue: end me timeValue: stepSize}

struct GraphDataStream {
    me string: title
    me double[our map timeValue]:: dataMap
    me cdColor: lineColor
    me cdColor: fillColor
    me bool: isVisible <- false
    me bool: hasGradient <- true
    me double: screenDataAvg
}

struct GraphDataStreamSources{
    our GraphDataStream[me list]: dataStreams
    their DataGen: parentDataSource
    me timeStepInterval: requestedInterval
    me bool: dataRangeChangeRequested

}

struct graph: inherits=dash COMMAND_addCallProxy="bundledArgs:applyDataRange"{
    our GraphDataStreamSources: dataStreamSrcs
    me string[list]: dataStreamsTitleTable <- ["None"]
    me int64: screenDataTotal
    me int: screenDataCount
    me timeValue: timeInterval
    me timeValue: crntRightSide

    me graphTitleWidget: graphTitle
    me verticalScale:   leftScale
    me horizontalScale: bottomScale
    me verticalScale:   rightScale
    me horizontalScale: topScale

    me mode[sAutomatic, sManual]:scrollMode
    me zoomWidget: zoomToggle
    me int: zoomLevel
    me timeValue: t0 <- 1000*60
    me timeValue: t1 <- 1000*60*60
    me timeValue: t2 <- 1000*60*60*6
    me timeValue: t3 <- 1000*60*60*12
    me timeValue: t4 <- 1000*60*60*24
    me timeValue: t5 <- 1000*60*60*24*7
    me timeValue: t6 <- 1000*60*60*24*14
    me timeValue[list]: zoomTable <- [t0,t1,t2,t3,t4,t5,t6, 2592000000, 5184000000, 7776000000, 15552000000, 31536000000]
    me string[list]: labelTable   <-   ["1 Minute","1 Hour","6 Hours","12 Hours","24 Hours","One Week","Two Weeks","30 Days","60 Days","90 Days","180 Days","One Year"]
    me streamToggle: streamToggle1
    me streamToggle: streamToggle2
    me bool: gradients

    void: update() <- {}

    void: setPos(me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: extCursor) <- {
        posIsSet <- true
        extC     <- extCursor
        extX     <- posX+width
        extY     <- posY+height
    }

    void: draw(me GUI_ctxt: cr) <- {
        me timeValue:  rightGraphTime
        me timeValue:  leftGraphTime
        me bool:       firstTime
        me GUI_Scalar:     XPoint
        me GUI_Scalar:     YPoint
        me GUI_Scalar: YOrig <- posY + height

        withEach ii in RANGE(0.. dataStreamSrcs.dataStreams.size()) {
            if (streamToggle1.state == ii + 1 or streamToggle2.state == ii + 1) {dataStreamSrcs.dataStreams[ii].isVisible <- true}
            else {dataStreamSrcs.dataStreams[ii].isVisible <- false}
            if (streamToggle1.state == 0 or streamToggle2.state == 0) {dataStreamSrcs.dataStreams[ii].hasGradient <- true}
            else {dataStreamSrcs.dataStreams[ii].hasGradient <- false}
        }

        withEach dataStream in dataStreamSrcs.dataStreams{
            screenDataTotal <- 0
            screenDataCount <- 0
            XPoint          <- 0
            YPoint          <- 0

            if (dataStream.isVisible) {
                me double: dblWidth <- width
                me double: dblHeight <- height
                cr.setLineWidth(2)
                if (crntRightSide > getCurrentTimeStamp()) {scrollMode <- sAutomatic}
                if (scrollMode==sAutomatic) {crntRightSide  <- getCurrentTimeStamp()}
                rightGraphTime <- crntRightSide
                leftGraphTime  <- crntRightSide - timeInterval
                firstTime      <- true
        /*
                /-/// Gradient - requires duplicate 'invisible' data plot as boundary
                if (dataStream.hasGradient) {
                    withEach point in dataStream.dataMap from leftGraphTime to rightGraphTime {
                        XPoint <- (point_key-leftGraphTime)*dblWidth/timeInterval + posX
                        YPoint <- (point - leftScale.lowVal)*dblHeight/(leftScale.hiVal - leftScale.lowVal)
                        if(firstTime){
                            cr.setColor(styler.bkGndColor)
                            cr.moveTo(XPoint, YOrig)
                            cr.lineTo(XPoint, YOrig - YPoint)
                            firstTime<-false
                        } else {cr.lineTo(XPoint, YOrig - YPoint)}
                    }
                    cr.lineTo(XPoint, YOrig)
                    their guiFillPattern: linGrad
                    linGrad.init(posX, YOrig-height, posX, YOrig)
                    linGrad.AddColorStopRGBA(0, dataStream.lineColor, 255)
                    linGrad.AddColorStopRGBA(1.0, styler.bkGndColor, 255)
                    cr.setFillPattern(linGrad)
                    cr.fillNow()
                    cr.strokeNow()
                    linGrad.destroy()
                }*/

                /-/// Visible data plot
                firstTime <- true
		if (dataStream.dataMap != NULL) {
		    withEach point in dataStream.dataMap from leftGraphTime to rightGraphTime {
			XPoint <- convertToGUIScalar((point_key-leftGraphTime)*dblWidth/timeInterval) + posX
			YPoint <- convertToGUIScalar((point - leftScale.lowVal)*dblHeight)/convertToGUIScalar(leftScale.hiVal - leftScale.lowVal)
			if(firstTime){
			    cr.setColor(dataStream.lineColor)
			    cr.moveTo(XPoint, YOrig - YPoint)
			    firstTime<-false
			} else {cr.lineTo(XPoint, YOrig - YPoint)}
			screenDataTotal <- screenDataTotal + convertToLongVal(point)
			screenDataCount <- screenDataCount + 1
		    }
		}
                cr.strokeNow()

                if (screenDataCount > 0) {dataStream.screenDataAvg <- screenDataTotal / screenDataCount}
                else {dataStream.screenDataAvg <- 0}
                if(streamToggle1.label == dataStream.title) {streamToggle1.latest <- dataStream.screenDataAvg}
                else if(streamToggle2.label == dataStream.title) {streamToggle2.latest <- dataStream.screenDataAvg}
            }
        }
        cr.setColor(styler.highlight2Color)
        if(leftScale.isVisible){
            leftScale.setScale(height, 0, 400, 50, posX, YOrig, -4)
            leftScale.draw(cr)
        }
        if(bottomScale.isVisible){
            bottomScale.setScale(width, leftGraphTime, rightGraphTime, zoomLevel, posX, YOrig, 4)
            bottomScale.draw(cr)
        }
        if(rightScale.isVisible){
            rightScale.setScale(height, 0, 10000000, 50, posX+width, YOrig, 4)
            rightScale.draw(cr)
        }
        if(topScale.isVisible){
            topScale.setScale(width, 0, 100, zoomLevel, posX, posY, -4)
            topScale.draw(cr)
        }

        if(graphTitle.isVisible) {graphTitle.draw(cr, posX + width/2, posY)}
        zoomToggle.draw(cr)
        streamToggle1.draw(cr)
        streamToggle2.draw(cr)
    }


    void: requestDataRange(me timeValue: start, me timeValue: end, me timeValue: stepSize) <-{
        dataStreamSrcs.requestedInterval.parentWidget <- self
        dataStreamSrcs.requestedInterval.start        <- start
	dataStreamSrcs.requestedInterval.end          <- end
	dataStreamSrcs.requestedInterval.stepSize     <- stepSize
	if (stepSize==0) {print("\nInvalid Step size in graph.requestDataRange()\n"); exit(1);}
        dataStreamSrcs.dataRangeChangeRequested       <- true
    }
    void: applyDataRange(me timeStepInterval: req) <- {
        crntRightSide <- req.end
        timeInterval  <- req.stepSize
        requestRedraw()
    }

    me void: initGraph(me string: titleStr, me GUI_Scalar: PosX, me GUI_Scalar: PosY, me bool: Gradients)<- {
        posX         <- PosX
        posY         <- PosY
        gradients    <- Gradients
        zoomLevel    <- 0
        title        <- 'Graph'

        withEach dataStream in dataStreamSrcs.dataStreams {
            dataStreamsTitleTable.pushLast(dataStream.title)
        }

        timeInterval <- zoomTable[zoomLevel]
        zoomToggle.initZoomWidget(90, 5, labelTable[zoomLevel], 10, 75)
        crntRightSide <- getCurrentTimeStamp()

            leftScale.initScale("Blood Glucose Level (ml/dl)", true, 1, false, false)
            rightScale.initScale("rightScale!", false, 1, false, false)
            bottomScale.initScale("Time", true, 1, false, true)
            topScale.initScale("topScale", false, 1, false, false)
        graphTitle.initGraphTitle(titleStr, false)
        streamToggle1.initStreamToggle(250, 5, dataStreamsTitleTable, 1)
        streamToggle2.initStreamToggle(400, 5, dataStreamsTitleTable, 0)

        requestDataRange(crntRightSide-timeInterval, crntRightSide, timeInterval)
    }

    void: incrementZoomLevel(me int: change) <- {
        if (zoomLevel + change >= 0 and zoomLevel + change < zoomTable.size()) {
            zoomLevel <- zoomLevel + change
            me timeValue: tmpTimeInterval <- zoomTable[zoomLevel]
            zoomToggle.label <- labelTable[zoomLevel]
            requestDataRange(crntRightSide-tmpTimeInterval, crntRightSide, tmpTimeInterval)
        }
    }

    /- Click and drag data horizontally
    me mode[still, fingerPressed, pullScrolling]: scrollState
    me GUI_Scalar: prevX
    me GUI_Scalar: deltaX <- 0
    me int: moveThreshold <- 2
    me GUI_Scalar: crntX
    me GUI_Scalar: crntY

    me bool: primaryDn(their GUI_ButtonEvent: event) <- {
        if (zoomToggle.zoomInBtn.primaryDn(event)) {}
        else if (zoomToggle.zoomOutBtn.primaryDn(event)) {}
        else {
            crntX <- event.x - posX
            crntY <- event.y - posY
            if (crntX <= 0 or crntX >= width or crntY <= 0 or crntY >= height) {return(false)}
            if (scrollState==still) {
                scrollState <- fingerPressed
                prevX <- event.x
            }
        }
        return(true)
    }

    me bool: primaryUp(their GUI_ButtonEvent: event) <- {
        if (zoomToggle.zoomInBtn.primaryUp(event)) {incrementZoomLevel(-1)}
        else if (zoomToggle.zoomOutBtn.primaryUp(event)) {incrementZoomLevel(1)}
        else if (streamToggle1.left.primaryUp(event)) {streamToggle1.incrementStreamState(-1, streamToggle2.state)}
        else if (streamToggle1.right.primaryUp(event)) {streamToggle1.incrementStreamState(1, streamToggle2.state)}
        else if (streamToggle2.left.primaryUp(event)) {streamToggle2.incrementStreamState(-1, streamToggle1.state)}
        else if (streamToggle2.right.primaryUp(event)) {streamToggle2.incrementStreamState(1, streamToggle1.state)}
        else {scrollState <- still}
        return(true)
    }

    me bool: mouseMoved(their GUI_MotionEvent: event) <- {
        deltaX <- event.x - prevX
        prevX <- event.x
        if (scrollState==fingerPressed and abs(deltaX) > moveThreshold) {
            scrollState <- pullScrolling
            scrollMode <- sManual
            deltaX <- 0
        }
        if (scrollState==pullScrolling) {
            me timeValue: tmpCrntRightSide <- crntRightSide - convertToTimeVal(deltaX)*timeInterval/convertToTimeVal(width)
            requestDataRange(tmpCrntRightSide-timeInterval, tmpCrntRightSide, timeInterval)
        }
        return(true)
    }
}
