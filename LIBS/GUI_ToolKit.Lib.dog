/- CodeDog GUI toolikt
requirements = [
    [require, GUI_ToolKit_implementation]
]

/- Set up a complete application: fonts, colors, a window/frame with a menu, toolbar, app area and optionally a statusbar.
/- Boilerplate details such as resizing windows, etc are taken care of in the best way for each platform.

struct cdColor{
    me uint: red
    me uint: green
    me uint: blue
}

struct ColorScheme{}
struct FontSpec{}
struct FontScheme{}

struct deltaSize{me int: width    me int: height}
struct GUI_rect{me double: x1 me double: y1 me double: x2 me double: y2}
struct GUI_offset{}
struct GUI_ctxt{}


struct GUI_item{}
struct GUI_menuBar{}
struct GUI_menu{}
struct GUI_menuItem{}
struct GUI_canvas{}
struct GUI_container{}
struct GUI_Frame{}
struct GUI_ScrollingWindow{}
struct GUI_callback{}
struct GUI_MotionEvent{}
struct INK_Image{}

struct GUI_button{}

/- GUI Widgets
struct boolWidget{}
struct floatWidget{}
struct rangeWidget{}
struct numRangeWidget {}
struct CGContext {}
struct CGPoint {}

struct intWidget{}
struct stringWidget{}
struct enumWidget{}
struct timeWidget{}
struct dateWidget{}
struct wizardWidget{
    their GUI_Frame:  box
    their GUI_ZStack: ZStack
    their GUI_Frame:  buttonBox /-Hstack
    their GUI_button: backBtn
    their GUI_button: nextBtn
    me int:           activeScreenIdx
    me string[list]:  children

    their GUI_Frame: makeWizardWidget(me string: name) <- {
        activeScreenIdx <- 0
        box             <- makeYStack("")
        ZStack          <- makeZStack("")
        buttonBox       <- makeXStack("")
        backBtn         <- makeButtonWidget("Back")
        nextBtn         <- makeButtonWidget("Next")
        GUI.setBtnCallback(backBtn, "clicked", clickBack, self)
        GUI.setBtnCallback(nextBtn, "clicked", clickNext, self)
        addToContainer(box, ZStack)
        addToContainer(buttonBox, backBtn)
        addToContainer(buttonBox, nextBtn)
        addToContainer(box, buttonBox)
        return(box)
    }
    void: clickNext() <-{
        activeScreenIdx <- activeScreenIdx+1
        me int: size <- children.size()
        if (activeScreenIdx > size-1){activeScreenIdx <-size-1}
        setActiveChild(activeScreenIdx)
    }
    void: clickBack() <-{
        activeScreenIdx <- activeScreenIdx-1
        if (activeScreenIdx < 0) {activeScreenIdx <-0}
        setActiveChild(activeScreenIdx)
    }
    void: setActiveChild(me int: N) <- {
        me string: childStr <- children[N]
        setZStackActive(ZStack, childStr)
        if(N==0){hideWidget(backBtn)}else{showWidget(backBtn)}
        if(N==children.size()-1){hideWidget(nextBtn)}else{showWidget(nextBtn)}
    }
}
struct matterTerm{
    me string[list]: matterTypes <- ["a", "b"]
    me int:          matterIdx   <- 0
    me double:       term        <- 0
    me string:       units       <- ""
}
struct MatterTermWidget{
    their GUI_Frame:    box
    their GUI_Label:    label
    their GUI_ComboBox: matterBox
    their GUI_SpinBox:  termBox
    their GUI_Label:    unitsBox
    
    our matterTerm::    data 
    me double: initialValue  <- 0
    me double: minValue      <- 0
    me double: maxValue      <- 1000
    me int:    decimalPlaces <- 0
    
    their GUI_Frame: makeMatterTermWidget(me string: name, our matterTerm: dataInit) <- {
        /-/// DATA //////////////////////////////////////
        data <- dataInit
        me string: units <- data.units
        /-/// MAKE WIDGETS //////////////////////////////
        box              <- makeXStack("")
        label            <- makeLabelWidget2(name)
        matterBox        <- makeComboBox()
        termBox          <- makeSpinBox(initialValue, minValue, maxValue, decimalPlaces)
        unitsBox         <- makeLabelWidget2(units)
        /-/// FILL WIDGETS //////////////////////////////
        matterBox.setAndroidAdapter(matterTermArrayAdapter, String, data.matterTypes)
        me int: count <-0
        withEach matterType in data.matterTypes{
            matterBox.appendStringComboBox(toString(count),matterType, matterTermArrayAdapter)
            count <- count +1
        }
        /-/// ADD WIDGETS //////////////////////////////
        addToContainer(box, label)
        addToContainer(box, matterBox)
        addToContainer(box, termBox)
        addToContainer(box, unitsBox)
        return(box)
    }
    our matterTerm: getValue() <- {
        our matterTerm: retVal
        Allocate(retVal)
        retVal.matterTypes <- data.matterTypes
        retVal.matterIdx   <- matterBox.comboBoxGetActive()
        retVal.term        <- termBox.getValue()
        retVal.units       <- data.units
        return(retVal)
    }
    void: setValue(our matterTerm: setVal) <- {
        data.matterIdx     <- setVal.matterIdx
        data.term          <- setVal.term
        data.units         <- setVal.units
    }
}
struct GUI{
    me void: showWidget(me GUI_item: widget)
    me GUI_item: newCanvas()
    me void: setWidgetSize(me GUI_item: widget, me uint32: width, me uint32: height)
/-    me GUI_item: newScrollingWindow()  /-
    me void: addToContainer(me GUI_container: container, me GUI_item: widget)
    me void: addToContainerAndExpand(me GUI_container: container, me GUI_item: widget)
    me void: addMenuBar(me GUI_menuBar: menubar)
    me void: create_MenuItem(me GUI_menu: ParentMenu, me string: label)
    me void: create_TopSubMenu(me GUI_menuBar: ParentMenu, me string: label)
    me void: create_SubMenu(me GUI_menu: ParentMenu, me string: label)
    me void: setCallback()
}

struct fontSpec{
    me string: name
    me int: size
    me mode[pp, dp, sp]: pixelMode

    none: fontSpec(me string: initName, me string: initSize) <- {
        name      <- initName
        size      <- stoi(initSize)
    }
}

struct Styler{
    #include LIBS/x11ColorsRGB.txt
}

struct GLOBAL{
    me floatWidget:     makeFloatWidget(me string: label)
    me numRangeWidget:  makeNumRangeWidget(me string: label)
    me rangeWidget:     makeRangeWidget(me string: label)
    me timeWidget:      makeTimeWidget(me string: label)
    me dateWidget:      makeDateWidget(me string: label)
}
struct GUI_ctxt {
    /-me void: fetchAreaToBeDrawn(me GUI_rect: area)
    me void: reset()
    me void: setRGBA(me double: red, me double: green, me double: blue, me double: alpha)
    me void: setRGB (me double: red, me double: green, me double: blue)
    me void: setColor(me cdColor: color)
    me void: setLineWidth(me double: width)
    me void: finishPDF()
    me void: setScale()
    me void: moveTo(me double: x, me double: y)
    me void: lineTo(me double: x, me double: y)
    me void: moveRel(me double: dx, me double: dy)
    me void: lineRel(me double: dx, me double: dy)
    me void: curveTo(me double: x1, me double: y1, me double: x2, me double: y2, me double: x3, me double: y3)
    me void: curveRel(me double: dx1, me double: dy1, me double: dx2, me double: dy2, me double: dx3, me double: dy3)
    me void: closePath()
    me void: rectangle()
    me void: paintNow()
    me void: strokeNow()
    me void: fillNow()
    me void: strokeKeep()
    me void: fillKeep()
    me void: setFillPattern()
    me void: circle(me int: centerX, me int: centerY, me int: radius)
}


/------------------------ Widgets and events

struct GUI_PointerEvent{}
struct GUI_ButtonEvent{}
struct GUI_KeyboardEvent{}
struct GUI_WindowEvent{}
struct GUI_DataEvent{}
struct GUI_TimeEvent{}
struct GUI_UserEvent{}
struct GUI_DrawEvent{}
struct GUI_Scalar{}


/- decor(ations) are like light weight widgets. They have only draw().

struct decor{
    void: draw(me GUI_ctxt: cr) <- {}
}

struct arrow: inherits=decor{
    me double: startX
    me double: startY
    me double: endX
    me double: endY

    me void: draw(me GUI_ctxt: cr) <- {
        me double: tipLength <- 10
        me double: tipAngle <- 0.35

        me double: angle <- atan2(endY - startY, endX - startX) + 3.14159265359

        me double: x1 <- endX + tipLength * cos(angle - tipAngle)
        me double: y1 <- endY + tipLength * sin(angle - tipAngle)
        me double: x2 <- endX + tipLength * cos(angle + tipAngle)
        me double: y2 <- endY + tipLength * sin(angle + tipAngle)

        cr.moveTo(startX, startY)
        cr.lineTo(endX, endY)
        cr.lineTo(x1, y1)
        cr.lineTo(x2, y2)
        cr.lineTo(endX, endY)
        cr.closePath()
        cr.fillKeep()
        cr.strokeNow()
    }

    none: arrow(me GUI_Scalar: StartX, me GUI_Scalar: StartY, me GUI_Scalar: EndX, me GUI_Scalar: EndY) <- {
        startX <- StartX
        startY <- StartY
        endX   <- EndX
        endY   <- EndY
    }
}

struct widget{
    me GUI_Scalar: posX    /- x position of top left corner
    me GUI_Scalar: posY    /- y position of top left corner
    me GUI_Scalar: width   /- width of widget
    me GUI_Scalar: height  /- height of widget
    me int: scale
    bool: isHidden

    void: draw(me GUI_ctxt: cr) <- {}
    me bool: handleAllClicks(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryDblClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryDn(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: primaryUp(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryDblClick(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryDn(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: secondaryUp(their GUI_ButtonEvent: event) <- {return(false)}
    me bool: mouseMoved(their GUI_MotionEvent: event) <- {return(false)}
    me bool: mouseDragged(their GUI_MotionEvent: event) <- {return(false)}
    me bool: mouseEnter(their GUI_MotionEvent: event) <- {return(false)}
    me bool: mouseExit(their GUI_MotionEvent: event) <- {return(false)}
    me bool: mouseWheel(their GUI_MotionEvent: event) <- {return(false)}
    me bool: fingerSqueeze(their GUI_PointerEvent: event) <- {return(false)}

    me bool: keyTyped(their GUI_KeyboardEvent: event) <- {return(false)}
    me bool: keyDown(their GUI_KeyboardEvent: event) <- {return(false)}
    me bool: keyUp(their GUI_KeyboardEvent: event) <- {return(false)}

    me bool: windowChange(their GUI_WindowEvent: event) <- {return(false)}
    me bool: dataUpdated(their GUI_DataEvent: event) <- {return(false)}         /- This widget's data has been updated
    me bool: timerTick(their GUI_TimeEvent: event) <- {return(false)}           /- Timer to change data
    me bool: tweenTick(their GUI_TimeEvent: event) <- {return(false)}           /- Timer for state-change animation frame
    me bool: userEvent(their GUI_UserEvent: event) <- {return(false)}
    me bool: focused(their GUI_PointerEvent: event) <- {return(false)}
    me bool: unfocused(their GUI_PointerEvent: event) <- {return(false)}

    bool: isTouchingMe(me GUI_Scalar: x, me GUI_Scalar: y) <- {
        return ((x >= posX) and (x < posX + width) and (y >= posY) and (y < posY + height))
    }

    void: initialize(me int: PosX, me int: PosY, me GUI_Scalar: Width, me GUI_Scalar: Height, me int: Scale, me int: Alpha ) <- {
        posX   <- PosX
        posY   <- PosY
        width  <- Width
        height <- Height
        scale  <- Scale
    }
}


/-///////////////////////////////  HIGHER LEVEL WIDGETS

struct ListWidgetManager{
    me ListManagerBox: ListEdBox
    their GUI_Frame[their list]: rows

    /- Override all these for each new list editing widget
    their listWidget: makeListViewWidget()  <- {return(NULL)}
    their GUI_item: makeListHeader()        <- {return(NULL)}
    void: updateViewableWidget()            <- {}
    their GUI_item: makeEditableWidget()    <- {return(NULL)}
    void: updateEditableWidget(me int: N)   <- {}
    void: updateCrntFromEdited(me int: N)   <- {}
    void: allocateNewCurrentItem()          <- {}
    me int: pushCrntToList(me int: N)       <- {return(0)}
    me int: deleteNthItem(me int: N)        <- {return(0)}
    void: deleteNthRow(me int: N)           <- {}
    void: copyCrntBackToList(me int: N)     <- {}
    void: copyCrntBackToListView(me int: N) <- {}
    void: setCurrentItem(me int: idx)       <- {}
    me int: getListLength()                 <- {return(0)}
    their GUI_Frame: getNthRow(me int: N)   <- {return(NULL)}
    void: handleAdd()    <- {}
    void: handleDelete() <- {}
    void: handleEdit()   <- {}


    /- Also, add their GUI_item: initWidget(<listType>)
}

/-//////////////////////////////////// MISC WIDGETS
struct DateWidget{
    their GUI_Frame:    box
    their GUI_Label:    dataLabel
    me timeValue:       data
    me string[list]:    months <- ['Jan', 'Feb', 'March', 'April', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec']
    me int[list]:       days 

    their GUI_Frame: initCrnt(me string: label) <- {
        me timeValue: crntTime <- getCurrentTimeStamp()
        box <- initialize(label, crntTime)
        return(box)
    }
}

struct TimeWidget{
    their GUI_Frame:    box
    their GUI_Label:    dataLabel
    their GUI_ComboBox: hourBox
    their GUI_ComboBox: minuteBox
    me timeValue:       data
    me int[list]:       hours
    me int[list]:       minutes 
  
    their GUI_Frame: initCrnt(me string: label) <- {
        me timeValue: crntTime <- getCurrentTimeStamp()
        box <- initialize(label, crntTime)
        return(box)
    }
}

struct DateTimeWidget{
    their GUI_Frame:  box
    their DateWidget: dateWidget
    their TimeWidget: timeWidget
    me timeValue:     data

    their GUI_Frame: initCrnt(me string: label) <- {
        me timeValue: crntTime <- getCurrentTimeStamp()
        box <- initialize(crntTime)
        return(box)
    }
    their GUI_Frame: initialize(me timeValue: defaultTime) <- {
        /-/// DATE ////////////////////////////////////
        Allocate(dateWidget)
        their GUI_Frame: dateBox <- makeYStack("")
        dateBox <- dateWidget.initCrnt("")
        /-/// TIME ////////////////////////////////////
        Allocate(timeWidget)
        their GUI_Frame: timeBox <- makeYStack("")
        timeBox <- timeWidget.initCrnt("")
        /-/// RETURN BOX //////////////////////////////
        box <- makeXStack("")
        addToContainer(box, dateBox)
        addToContainer(box, timeBox)
        return(box)
    }
    me timeValue: getValue() <- {
        me timeValue: tmpDate <- dateWidget.getValue()
        me timeValue: tmpTime <- timeWidget.getValue()
        me timeValue: retVal  <- tmpDate + tmpTime
        return(retVal)
    }
    void: setValue() <- {}
}
/*struct FoodData {
    me bool: isVisible <- true
    me string: name
    me int: quantity
    me int: unitIdx
    
    me double: carb
    me double: fat
    me double: protein
    me double: glycIdx
    
    their FoodDataWidget: widget
}
struct MealData {
    me FoodData[list]: data
}
struct FoodDataWidget {    
    their GUI_Label: foodNameLabel
    their GUI_Completer: foodNameCompleter
    their GUI_Label: quantityNameLabel
    their GUI_Entry: quantityEntryField
    their GUI_Label: unitNameLabel
    me string[list]: unitChoices
    their GUI_ComboBox: unitComboBox
    their GUI_item: boxEntry
    their GUI_button: removeBtn
    me int: foodIdx
    their MealDataWidget: parent
    
    their GUI_item: makeFoodDataWidget(me int: FoodIdx, their MealDataWidget: Parent) <- {
	parent <- Parent
	foodIdx <- FoodIdx
	boxEntry <- makeXStack("")
	me string: foodNameStr <- "Item"
	me string: quantityNameStr <- "Quantity"
	me string: unitNameStr <- "Units"
	unitChoices <- ["ounces", "fluid ounces"]
	foodNameLabel <- makeLabelWidget2(foodNameStr)
	foodNameCompleter <- makeCompleterBox("")
	quantityNameLabel <- makeLabelWidget2(quantityNameStr)
	quantityEntryField <- makeEntryBox("")
	unitNameLabel <- makeLabelWidget2(unitNameStr)
	unitComboBox <- makeComboBox("")
	withEach unit in unitChoices {addToComboBox(unitComboBox, unit)}
	removeBtn <- makeButtonWidget("Remove")
	GUI.setBtnCallback(removeBtn, "clicked", clickRemove, self)
	
	showWidget(foodNameLabel)
	showWidget(foodNameCompleter)
	showWidget(quantityNameLabel)
	showWidget(quantityEntryField)
	showWidget(unitNameLabel)
	showWidget(unitComboBox)
	showWidget(removeBtn)
	
	addToContainer(boxEntry, foodNameLabel)
	addToContainer(boxEntry, foodNameCompleter)
	addToContainer(boxEntry, quantityNameLabel)
	addToContainer(boxEntry, quantityEntryField)
	addToContainer(boxEntry, unitNameLabel)
	addToContainer(boxEntry, unitComboBox)
	addToContainer(boxEntry, removeBtn)
	return(boxEntry)
    }
    void: clickRemove() <- {
	hideWidget(foodNameLabel)
	hideWidget(foodNameCompleter)
	hideWidget(quantityNameLabel)
	hideWidget(quantityEntryField)
	hideWidget(unitNameLabel)
	hideWidget(unitComboBox)
	hideWidget(removeBtn)
	parent.data.data[foodIdx].isVisible <- false
    }
}
struct MealDataWidget {
    their GUI_item: box
    their GUI_item: boxHeader
    their GUI_item: boxBody
    their GUI_item: boxFooter
    their GUI_Label: label
    their GUI_button: addFoodBtn
    their GUI_button: testSaveBtn
    me MealData: data
    me int: foodCount <- 0
    
    their GUI_item: makeMealDataWidget(me string: Name, me MealData: Data) <- {
	me FoodData: food1
	data.data <- [food1]
	
	label <- makeLabelWidget2(Name)
	addFoodBtn <- makeButtonWidget("Add Item")
	testSaveBtn <- makeButtonWidget("Save")
	GUI.setBtnCallback(addFoodBtn, "clicked", clickAdd, self)
	/-GUI.setBtnCallback(testSaveBtn, "clicked", clickSave, self)
	
	boxHeader <- makeXStack("")
	addToContainer(boxHeader, label)
	/- Expand/Contract button
	
	boxBody <- makeYStack("")
	withEach item in data.data {
	    their FoodDataWidget:: itemWidget
	    item.widget <- itemWidget
	    addToContainer(boxBody, itemWidget.makeFoodDataWidget(foodCount, self))
	    foodCount <- foodCount + 1
	}
	
	boxFooter <- makeXStack("")
	addToContainer(boxFooter, addFoodBtn)
	addToContainer(boxFooter, testSaveBtn)
	
	box <- makeYStack("")
	addToContainer(box, boxHeader)
	addToContainer(box, boxBody)
	addToContainer(box, boxFooter)
	return(box)
    }
    void: clickAdd() <- {
	me FoodData: food
	
	their FoodDataWidget:: itemWidget
	their GUI_item:: newItem 
	newItem <- itemWidget.makeFoodDataWidget(foodCount, self)
	food.widget <- itemWidget
	data.data.pushLast(food)
	showWidget(newItem)
	addToContainer(boxBody, newItem)
	foodCount <- foodCount + 1
	withEach item in data.data {
	    print(item.isVisible)
	}
	print("\n")
    }
    void: getValue() <- {
	print("Save!\n")
	withEach item in data.data {
	    if (item.isVisible) {
		print("VISIBLE!\n")
		item.name <- item.widget.foodNameCompleter.getValue()
		item.quantity <- item.widget.quantityEntryField.getValueAsInt()
		item.unitIdx <- item.widget.unitComboBox.comboBoxGetActive()
	    } else {print("NOPE\n")}
	}
	withEach food in data.data {
	    if (food.isVisible) {
		print(food.name)
		print("\n")
		print(food.quantity)
		print("\n")
		print(food.unitIdx)
		print("\n")
	    }
	}
    }
}*/
struct Agreement{
    me string: fileName
    me bool:   doesAgree 
}
struct AgreeWidget{
    their GUI_Frame:            box
    their GUI_VerticalScroller: textScroller
    their GUI_TextViewer:       textBox
    their GUI_Frame:            agreeFrame
    their GUI_Label:            agreeLabel
    their GUI_Bool:             agreeCheckBox
    me Agreement:               agreement
    me string:                  bodyTxt 
    
    their GUI_Frame: makeAgreeWidget(me string: fileName) <- {
        agreement.fileName <- fileName
        bodyTxt            <- readAssetAsString(agreement.fileName)
        textScroller       <- makeVerticalScroller(1000,500)
        textBox            <- makeTextViewer(bodyTxt)
        /-/// CHECKBOX ////////////////////////////////
        agreeFrame         <- makeXStack("")
        agreeLabel         <- makeLabelWidget("I Accept")
        agreeCheckBox      <- makeCheckBox()
        /-/// RETURN BOX //////////////////////////////
        box                <- makeYStack("")
        addToContainer(textScroller, textBox)
        addToContainer(agreeFrame, agreeLabel)
        addToContainer(agreeFrame, agreeCheckBox)
        addToContainer(box, textScroller)
        addToContainer(box, agreeFrame)
        return(box)
    }
    me bool: getValue()            <- {agreeCheckBox.getValue()}
    void: setValue(me bool: value) <- {}
    void: setText(me string: text) <- {}
}
