//############  Add GUI-Toolkit features using GTK3
requirements = [
    [tagOneOf, Platform, [MacOS]]
]

interface={
    provides=[GUI_ToolKit_implementation]
    libFiles=[``]
    headers=[AppKit]
}

LibDescription ={
    useStatus   = dynamic
    description ='AppKit is a GUI Toolkit'
    features    =[GUI_ToolKit, Mouse, Keyboard, Audio]
    platforms   =[MacOS]
    bindings    =[Swift]
}

initCode = ``

embedVeryHigh = `
// APP DELEGATE /////////////////////////////////////////////////////
class AppDelegate: NSObject, NSApplicationDelegate {
    func applicationDidFinishLaunching(_ aNotification: Notification) {
        window = NSWindow(contentRect: NSMakeRect(0, 0, NSScreen.main?.frame.width ?? 1000, NSScreen.main?.frame.height ?? 1000),
            styleMask: [.miniaturizable, .closable, .resizable, .titled],
            backing: .buffered,
            defer: false)
        window.contentViewController = ViewController()
        window.makeKeyAndOrderFront(nil)
    }
}
// VIEW CONTROLLER ///////////////////////////////////////////////
class ViewController: NSViewController {
    override func loadView() {
        screenSurface = Canvas(frame: NSRect(x: 0, y: 0, width: NSScreen.main?.frame.width ?? 1000, height: NSScreen.main?.frame.height ?? 1000))
        self.view = screenSurface
    }
}
`

/////////////////////////////////  STRUCT CONVERTERS
struct GUI_rect                 {me double: x1 me double: y1 me double: x2 me double: y2}
struct GUI_item:                wraps = NSView{}
struct GUI_Frame:               wraps = NSView{}
struct GUI_canvas:              wraps = CanvasView{}
struct GUI_container:           wraps = NSView{}
struct INK_Image:               wraps = Canvas{}      // How will the ink look?
struct GUI_callback:            wraps = GCallback{}
struct GUI_Scalar:              wraps = Int{}
struct GUI_Text:                wraps = GtkWidget{}
//struct GDK_KEY_Down:          wraps = ???{}
struct GUI_MouseEvent:          wraps = MotionEvent{}
struct GUI_MotionEvent:         wraps = MotionEvent{}
struct GUI_ButtonEvent:         wraps = MotionEvent{}
struct GUI_PointerEvent:        wraps = MotionEvent{}
struct GUI_KeyboardEvent:       wraps = MotionEvent{}
struct GUI_ctxt:                wraps = CGContext{}
/////////////////////////////////  GLOBAL WIDGET FUNCTIONS
struct GLOBAL{
    me void: addToContainerAndExpand(me GUI_container: container, me GUI_item: widget) <- <%!%G%>
}
/////////////////////////////////  HANDLE EVENTS

struct GUI_MouseEvent{
    me int: x <- <%!getX()%>
    me int: y <- <%!getY()%>
}

struct GUI_MotionEvent{
    me int: x <- <%!getX()%>
    me int: y <- <%!getY()%>
}

struct GUI_ButtonEvent{
    me int: x <- <%!getX()%>
    me int: y <- <%!getY()%>
}

struct GUI_PointerEvent{
    me int: x <- <%!getX()%>
    me int: y <- <%!getY()%>
}

/////////////////////////////////  EVENT DISPATCHER
struct GUI_eventDispatcher{
    their widget: topWidget

    me bool: dispatchPointerClickEvent(their GUI_MouseEvent: event) <- <%{
        var returnVal: Bool = false

        switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            topWidget.primaryDn(event);
            returnVal = true;
            break;
        case MotionEvent.ACTION_MOVE:
            topWidget.mouseMoved(event);
            returnVal = true;
            break;
        case MotionEvent.ACTION_UP:
            topWidget.primaryUp(event);
            returnVal = true;
            break;
        case MotionEvent.ACTION_CANCEL:
            returnVal = true;
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            returnVal = true;
            break;
        case MotionEvent.ACTION_POINTER_UP:
            returnVal = true;
            break;
        default:
            return false;
        }

        return returnVal;
    }%>

    me void: registerWidgetForEventDispatcher(me CanvasView: appWidget, their widget: masterWidget) <- {
        topWidget<-masterWidget
    }
}

/////////////////////////////////  HANDLE GUI
struct CanvasView: inherits=NSView{
    me GUI_ctxt: cr
    our DashboardWidget:  parent
    me float: scaleFactor

    me none: CanvasView() <- <%{}%>
    me void: draw(me NSRect: dirtyRect) <- <%{
        super.draw(dirtyRect)
        let cr: CGContext! = NSGraphicsContext.current?.cgContext
        parent.EventDispatcher.topWidget.draw(cr)
    }%>
    me void: setParent(our DashboardWidget: wid) <- {parent <- wid}
}

/////////////////////////////////  HANDLE GUI
struct GUI{
    me LinearLayout: frame
    me LinearLayout: layoutArea
    me NestedScrollView: scroller

    me none: GUI() <- {}

    me void: GUI_PopulateAndExec() <- <%{
    }%>

    me uint32: GUI_Init() <- <%{
        return(0);
    }%>

    me uint32: GUI_Run() <- <%{
        return(0);
    }%>

    me void: GUI_Deinit() <- {}
}

struct GUI{
    //their GUI_item: newCanvas() <- <%!%>
    //me void: setWidgetSize(me GUI_item: widget, me uint32: width, me uint32: height) <- <%!%>
    //their GUI_item: newScrollingWindow() <- <%!%>
    //me void: addMenuBar(me GUI_menuBar: menubar) <- <%!%>
    //me GUI_Frame: GUI_Frame(me string: label) <- <%!%>
}

struct GUI_ctxt{
    //me void: fetchAreaToBeDrawn(me GUI_rect: area) <- <%!%>
    //me void: reset()                                  <- <%!%>
    //me void: setRGBA(me double: red, me double: green, me double: blue, me double: alpha) <- <%!%>
    //me void: setRGB (me double: red, me double: green, me double: blue) <- <%!%>
    //me void: setColor(me cdColor: color)              <- <%!%>
    //me void: setLineWidth(me double: width)           <- <%!%>
    //me void: finishPDF()                              <- <%!%>
    //me void: setScale()                               <- <%!%>
    //me void: moveTo(me double: x, me double: y)       <- <%!%>
    //me void: lineTo(me double: x, me double: y)       <- <%!%>
    //me void: moveRel(me double: dx, me double: dy)    <- <%!%>
    //me void: lineRel(me double: dx, me double: dy)    <- <%!%>
    //me void: curveTo(me double: x1, me double: y1, me double: x2, me double: y2, me double: x3, me double: y3) <- <%!%>
    //me void: curveRel(me double: dx1, me double: dy1, me double: dx2, me double: dy2, me double: dx3, me double: dy3) <- <%!%>
    //me void: closePath()                              <- <%!%>
    //me void: rectangle()                              <- <%!%>
    //me void: paintNow()                               <- <%!%>
    //me void: strokeNow()                              <- <%!%>
    //me void: fillNow()                                <- <%!%>
    //me void: strokeKeep()                             <- <%!%>
    //me void: fillKeep()                               <- <%!%>
    //me void: renderFrame()                            <- <%!%>
    //me void: setFillPattern()                         <- <%!%>
    //me void: circle(me int: centerX, me int: centerY, me int: radius) <- <%!%>
    me GUI_ctxt: newPDF_ctxt(me sting: filename, me double: inchesWide, me double: inchesHigh) <- {}
}

struct GUI_ctxt{
    me Paint: paint
    me Path: GPath
    me double: cur_x
    me double: cur_y
    me Canvas: GCanvas

    me none: GUI_ctxt () <- {
        Allocate(paint)
        Allocate(GPath)
    }

    me none: GUI_ctxt(me Canvas: canvas) <- {
        Allocate(paint)
        Allocate(GPath)
        GCanvas <- canvas
    }
}

struct APP: inherits=LinearLayout{
    //me none: APP() <- <%{}%>
}
/////////////////////////////////  G L O B A L
struct GLOBAL: inherits=AppCompatActivity{
    their LinearLayout: window
    //me int: widgetHeight()    <- <%!%>
    //me int: widgetWidth()     <- <%!%>
    //me long: ticksPerSec()    <- <%!%>
    me Toolbar: toolbar
    me int: displayHeightPx
    me int: displayWidthPx

    // //DRAWING ROUTINES:
    //me deltaSize: renderText(me GUI_ctxt: cr, me string: text, me fontSpec: font, me double: x, me double: y) <- <%{}%>
    //me deltaSize: renderTextCentered(me GUI_ctxt: cr, me string: text, me fontSpec: font, me double: x, me double: y) <- <%{}%>
    //me deltaSize: renderTextRotate(me GUI_ctxt: cr, me string: text, me fontSpec: font, me double: x, me double: y, me double: degrees, me string: justify) <- <%{}%>
    //me void: rotate(me GUI_ctxt: cr, me double: x, me double: y, me int: degrees) <- <%{}%>
    //me void: restore(me GUI_ctxt: cr) <- <%!%>
    //me deltaSize: getTextSize(me GUI_ctxt: cr, me string: text, me fontSpec: font) <- <%{}%>
    //me void: roundedRectangle(me GUI_ctxt: cr, me double: x, me double: y, me double: w, me double: h, me double: r) <- <%{}%>
    //me void: displayImage(me GUI_ctxt: cr, me string: filename, me double: x, me double: y, me double: scale) <- <%{}%>

    // //GUI INTERFACE:
    me void: onCreate() <- <%{
        thisApp = APP();
        initialize("");
        getMetrics();
        runDogCode();
    }%>

    //me void: copyAssetToWritableFolder(me string: fromPath, me string: toPath)<- <%{}%>
    //me void: getMetrics()       <- <%{}%>
    //me void: setFontScale()     <- <%{}%>
    //me void: showWidget(me GUI_item: widget) <-  <%!%>
    //me void: hideWidget(their GUI_item: widget) <- <%!%>
    //me void: markDirtyArea(me GUI_item: widget, me int32: x, me int32: y, me int32: width, me int32: height) <- <%!%>
    //me GUI_item: newCanvas() <- <%!%>
   // me void: setWidgetSize(me GUI_item: widget, me uint32: width, me uint32: height) <- <%!%>
}

/////////////////////////////////  INTER-THREAD COMMUNICATION
