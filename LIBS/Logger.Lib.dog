//####### Logger library

requirements = [
    [require, Logger_implementation]
]
featuresNeeded = [List, Threads]

initCode = `
    logMgr.init(OFile)
`
struct LogLevel: inherits=<mode[Mesg, Info, Critical, FatalError, Warning, Debug]> {}
struct logger{
    me string: logStr
    me bool: showTimeStamp
    me bool: showLogLevel
    me bool: showThreadID
    me LogLevel: logLevel
    me Map<me string, me bool>: filters
    me Mutex: loggerMutex
    me void: Route(me string: routeSpec)
    me void: LogEntry(me int: level, me string: category, me string: logText, me int: indent<-0) <- {
        me MutexMngr: MtxMgr{loggerMutex}
        me string: logMsg
        if(showLogLevel) {logMsg <+- ":" + LogLevelStrings[level].subStr(0,1)}
        if(showTimeStamp){logMsg <+- ":" + toString(currentTimeStamp())}
        if(showThreadID) {logMsg <+- ":" + thisThreadID()}
        logMsg <+- ":" + logText
        logMgr.writeToLog(logMsg)
    }
}

struct logManager{
    me string: logFileName  <- "codeDog.log"
    me logger: logger
    me mode [ONone, OConsole, OFile, OBoth]: outputMode
    me bool: useLogFile
    me bool: useConsole
    //me void: assert(me string: condition)

    //ShowLogs(InfoLogs | MesgLogs | ...) // ALL_LOGS = the OR of all of them
    //HideLogs(InfoLogs | MesgLogs | ...)
    //RouteLogs(FILE) // Options: stdOut, A file, the platform's system logs, a string
    me void: openLogFile()
    me void: writeToLog(me string: txt)

    me void: init(me int: outMode) <- {
        outputMode <- outMode
        if(outputMode == OFile or outputMode == OBoth){useLogFile <- true; openLogFile();}
        else{useLogFile <- false}
        if(outputMode == OConsole or outputMode == OBoth){useConsole <- true;}
        else{useConsole <- false}
    }
}

struct GLOBAL{
    me logManager: logMgr

    void: logSeg(me string: logTxt) <- {me MutexMngr: MtxMgr{logMgr.logger.loggerMutex}; logMgr.logger.logStr <+- logTxt}
    void: logSegIn(me string: segID)<-{me MutexMngr: MtxMgr{logMgr.logger.loggerMutex}; logMgr.logger.logStr <+- "--"+segID+":["}
    void: logSegOut(me string: retID)<-{me MutexMngr: MtxMgr{logMgr.logger.loggerMutex}; if(retID!=""){retID<-":"+retID} logMgr.logger.logStr <+- "]"+retID}
    void: logSegStartCol(me string: logTxt, me int: startPos) <- {
        me MutexMngr: MtxMgr{logMgr.logger.loggerMutex};
        me int: strLength <- logMgr.logger.logStr.size()
        if(strLength < startPos){
            me int: lenDiff <- startPos - strLength
            withEach i in RANGE(0..lenDiff){
                logMgr.logger.logStr <+- " "
            }
        }
        logMgr.logger.logStr <+- logTxt
    }
    void: logSegClear() <- {me MutexMngr: MtxMgr{logMgr.logger.loggerMutex}; logMgr.logger.logStr <+- ""}
    void: logFlush() <- {me MutexMngr: MtxMgr{logMgr.logger.loggerMutex}; logMgr.writeToLog("MESG: "+logMgr.logger.logStr); logMgr.logger.logStr <- ""}
    //void: logFlush() <- {logMgr.writeToLog("MESG: "+logMgr.logger.logStr); logMgr.logger.logStr <- ""}
    //me void: assert(me string: condition) <- {}

    me string: shortedStr(me string: str, me int: len) <- {
        if(str.size()<=len){return(str)}
        me int: endLen    <- len/3
        me int: startLen  <- len-endLen
        return(str.subStr(0, startLen) + " ### " +str.subStr(str.size()-endLen))
    }

    me void: log(me string: logText, me string: category<-"", me int: indent<-0)           <- {logMgr.logger.LogEntry(Mesg, category, logText, indent)}
    me void: logInfo(me string: logText, me string: category<-"", me int: indent<-0)       <- {logMgr.logger.LogEntry(Info, category, logText, indent)}
    me void: logCritical(me string: logText, me string: category<-"", me int: indent<-0)   <- {logMgr.logger.LogEntry(Critical, category, logText, indent)}
    me void: logFatalError(me string: logText, me string: category<-"", me int: indent<-0) <- {logMgr.logger.LogEntry(FatalError, category, logText, indent); exit(-1)}
    me void: logWarn(me string: logText, me string: category<-"", me int: indent<-0)       <- {logMgr.logger.LogEntry(Warning, category, logText, indent)}
    me void: logDbg(me string: logText, me string: category<-"", me int: indent<-0)        <- {logMgr.logger.LogEntry(Debug, category, logText, indent)}
}
