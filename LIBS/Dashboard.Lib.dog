// CodeDog GUI DashBoard

// Widgets for constructing a dashboard

featuresNeeded = [GUI_ToolKit, Logger]


struct dash: inherits=widget{
    me string: title
    me GUI_Scalar: extX        // Dashes right-most extent
    me GUI_Scalar: extY        // Dashes lowest extent
    me GUI_Scalar: extC        // The current position where the next external item should be drawn
    their dash: dashParent
    me bool: isNullLike
    me bool: posIsSet
    me bool: isDirty

    void: setPos(me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: extCursor) <- {
        posX <- x
        posY <- y
        extC <- extCursor
    }
    void: addDependent(me string: key, their dash: dashPtr) <- {
        if(dashPtr.dashParent==NULL){dashPtr.dashParent<-self}
        dashParent.addDependent(key, dashPtr)
    }
    their dash: dependentIsRegistered(me string: key) <- {
        if(dashParent==NULL){log("In dash.dependentIsRegistered("+key+") dashParent was NULL")}
        return(dashParent.dependentIsRegistered(key))
    }
    void: requestRedraw() <- {
        if(dashParent==NULL){log("In Dash.requestRedraw() dashParent was NULL")}
        isDirty<-true; dashParent.requestRedraw()
    }
    void: activatePropertyEditor() <- {}
    void: addRelation(me string: relationType, their dash: from, their dash: to) <- {
        if(dashParent==NULL){log("In Dash.addRelation() dashParent was NULL")}
        dashParent.addRelation(relationType, from, to)
    }

    me bool: mouseMoved(their GUI_MotionEvent: event) <- {
        if(!checkForMouseOver(event)){return(false)}
        return(true)
    }

    their DashboardWidget: getDashBrdMngr()<-{return(dashParent.getDashBrdMngr())}
}

struct Dashboard: inherits=dash{
    me List<our dash>: dashChildren
    me Map<me string, their dash>: dependentItems
    me List<our decor>: decorations
    me string: bgImageFilename
    mode[accomodateParent, accomodateContent]: sizingMode
    mode[userArranges, singleDash, verticalStack]: layoutMode
    their GUI_ctxt: myGUI_ctxt

    their dash: dependentIsRegistered(me string: key) <- {
        if(dependentItems.containsKey(key)){
            return(dependentItems.at(key))
        }
        return(NULL)
    }

    me void: addChild(our dash: child) <- {child.dashParent<-self; dashChildren.pushLast(child)}

    void: addDependent(me string: key, their dash: dashPtr) <- {
        if(! dependentItems.containsKey(key)){
            dashPtr.isHidden <- true
            dependentItems[key] <- dashPtr
        }
    }

    me void: addArrow(their dash: from, their dash: to) <- {
        me GUI_Scalar: fromX    <- from.posX+155
        me GUI_Scalar: fromY    <- from.posY+12
        me GUI_Scalar: smallToX <- to.posX
        me GUI_Scalar: largeToX <- to.posX + to.width
        me GUI_Scalar: smallToY <- to.posY
        me GUI_Scalar: largeToY <- to.posY + to.height
        our arrow: Arrow {fromX, fromY, intersectPoint(fromX, smallToX, largeToX), intersectPoint(fromY, smallToY, largeToY)}
        decorations.pushLast(Arrow)
    }

    void: addRelation(me string: relationType, their dash: from, their dash: to) <- {
        if(relationType=='arrow'){
            addArrow(from, to)
        }
    }

    void: requestRedraw() <- {
        if(dashParent==NULL){log("In Dashboard.requestRedraw() dashParent was NULL")}
        isDirty<-true;
        dashParent.requestRedraw()
    }

    me bool: basePrimaryClick(their GUI_ButtonEvent: event) <- {
        if(! isTouching(event.x, event.y)){return(false)}
        withEach child in dashChildren{
            child.primaryClick(event)
        }
        withEach Dash in dependentItems{
            if(! Dash.isHidden){
                Dash.primaryClick(event)
            }
        }
        requestRedraw()
        return(true)
    }
    me bool: primaryClick(their GUI_ButtonEvent: event) <- {return(basePrimaryClick(event))}

    me bool: baseSecondaryClick(their GUI_ButtonEvent: event) <- {
        if(! isTouching(event.x, event.y)){return(false)}
        withEach child in dashChildren{
            child.secondaryClick(event)
        }
        withEach Dash in dependentItems{
            if(! Dash.isHidden){
                Dash.secondaryClick(event)
            }
        }
        setPos(15, 15, 35)
        requestRedraw()
        return(true)
    }
    me bool: secondaryClick(their GUI_ButtonEvent: event) <- {return(baseSecondaryClick(event))}

    me bool: basePrimaryDn(their GUI_ButtonEvent: event) <- {
        if(! isTouching(event.x, event.y)){return(false)}
        withEach child in dashChildren{
            child.primaryDn(event)
        }
        withEach Dash in dependentItems{
            if(! Dash.isHidden){
                Dash.primaryDn(event)
            }
        }
        return(true)
    }
    me bool: primaryDn(their GUI_ButtonEvent: event) <- {return(basePrimaryDn(event))}

    me bool: basePrimaryUp(their GUI_ButtonEvent: event) <- {
        if(! isTouching(event.x, event.y)){return(false)}
        withEach child in dashChildren{
            child.primaryUp(event)
        }
        withEach Dash in dependentItems{
            if(! Dash.isHidden){
                Dash.primaryUp(event)
            }
        }
        return(true)
    }
    me bool: primaryUp(their GUI_ButtonEvent: event) <- {return(basePrimaryUp(event))}

    me bool: mouseMovedBase(their GUI_MotionEvent: event) <- {
        if(!checkForMouseOver(event)){return(false)}
        withEach child in dashChildren{
            child.mouseMoved(event)
        }
        withEach Dash in dependentItems{
            if(! Dash.isHidden){
                Dash.mouseMoved(event)
            }
        }
        return(true)
    }
    me bool: mouseMoved(their GUI_MotionEvent: event) <- {return(mouseMovedBase(event))}

    me void: drawToPDF(me string: filename, me double: inchesWide, me double: inchesHigh, me double: scale) <- {
        //their GUI_ctxt: PDF <- myGUI_ctxt.newPDF_ctxt(filename, inchesWide, inchesHigh)
        //PDF.setScale(scale, scale)
        //draw(PDF)
        //PDF.finishPDF()
    }

    //me bool: secondaryClick(their GUI_ButtonEvent: event) <- {print("RIGHT BUTTON!\n"); drawToPDF('infonView.pdf', 11.0, 8.5, 0.4); return(true)}

    void: init(me string: label) <- {
        title <- label+".Dashboard"
        isHidden <- false
    }

    void: update() <- {log("base::update")}

    void: setPos(me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: extCursor) <- {
        me GUI_Scalar: YCursor <- y
        decorations.clear()
        width <- 10
        height <- 10
        withEach Dash in dependentItems{
            Dash.isHidden<-true
            Dash.posIsSet<-false
        }
        withEach child in dashChildren{
            extY <- YCursor+25
            child.setPos(x, YCursor, extY)
            width<-max(width, child.extX)
            height<-max(height, child.height+YCursor)
            YCursor <- child.extY + 30
        }
        withEach depDash in dependentItems{
            if(!depDash.isHidden){
                width<-max(width, depDash.extX)
                height<-max(height, depDash.extY)
            }
        }
        width <- width +30
        height <- height +30
    }
    // TODO: Support other layouts: verticalStack and userArranges
    void: layoutChildDashes() <- {
        me GUI_Scalar: verticalOffset   <- 0
        me GUI_Scalar: horizontalOffset <- 0
        if(sizingMode==accomodateContent){}
        if(layoutMode==singleDash){
            dashChildren[0].width <- width
            dashChildren[0].height <- height
        }else if(layoutMode==verticalStack){
            verticalOffset <- 15
            withEach childDash in dashChildren{
                childDash.setPos(15, verticalOffset, 0)
                verticalOffset <- childDash.extY+ 10
                horizontalOffset <- max(horizontalOffset, childDash.extX)
            }
        }else if(layoutMode==userArranges){
        }
    }

    void: baseDraw(their GUI_ctxt: cr) <- {
        if (isHidden){return()}
        layoutChildDashes()
        me cdColor: bkCol <- styler.bkGndColor
        me cdColor: fgCol <- styler.frGndColor
        if(bgImageFilename!=""){
            displayBackgroundImage(cr, bgImageFilename)
        } else {
            //    cr.setColor(bkCol)
            //    cr.paintNow()
        }

        cr.setLineWidth(2)
        withEach childDash in dashChildren{
            cr.setColor(fgCol)
            childDash.draw(cr)
        }
        withEach depDash in dependentItems{
            if(!depDash.isHidden){
                depDash.draw(cr)
            }
        }
        withEach decoration in decorations{
            decoration.draw(cr)
        }
    }
    void: draw(their GUI_ctxt: cr) <- {baseDraw(cr)}
}

struct dataField: inherits=dash{
    me string: label
    me string: value
    me int: midPos
    void: update(me int:MidPos, me int:minWidth, me string: Label, me string: Value, me bool: hideThis) <- {
        isNullLike<-hideThis
        midPos<-MidPos; label<-Label; value<-Value;
    }

   void: setPos(me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: extCursor) <- {
        posIsSet <- true
        posX   <- x
        posY   <- y
        extC   <- extCursor
        height <- 15
        width  <- 180
        extX   <- posX+width
        extY   <- posY+height
    }

    void: draw(their GUI_ctxt: cr) <- {
        if (isHidden){return()}
        renderText(cr, label, styler.smallFont, posX, posY+15)
        renderText(cr, value, styler.smallFont, posX+midPos, posY+15)
    }
}

struct ptrToItem: inherits=dash{
    me dataField: header
    me bool: refHidden
    me string: symbol
    their dash: dashPtr

    void: update(me string: Label, me string: textValue, me bool: hideThis) <- {
        isNullLike<-hideThis
        symbol <- textValue
        header.update(100, 180, Label, textValue, false)
    }

    void: setPos(me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: extCursor) <- {
        posIsSet <- true
        posX <- x
        posY <- y
        extC <- extCursor
        header.setPos(x, y, extY)
        height <- header.height
        width <- header.width
        dashPtr <- dependentIsRegistered(symbol)
        if((!refHidden) and dashPtr!=NULL and dashPtr.isHidden){
            dashPtr.isHidden<-false
        }
        extX <- posX+width
        extY <- posY+height
    }

    me bool: primaryClick(their GUI_ButtonEvent: event) <- {
        if(!isTouching(event.x, event.y)){return(false)}
        if(refHidden){refHidden<-false}
        else {refHidden<-true}
        return(true)
    }

    void: draw(their GUI_ctxt: cr) <- {
        if (isHidden){return()}
        header.isHidden <- false
        header.draw(cr)
    }

    void: INIT()<-{refHidden<-true}
}

struct listOfItems: inherits=dash{
    me mode[headerOnly, fullDisplay, noZeros]: displayMode
    me mode[vertical, horizontal]: orientation
    me dataField: header
    our List<our dash>: elements

    void: update(me string: Label, me string: textValue, me bool: hideThis, me bool: clear <- true) <- {
        isNullLike<-hideThis
        header.update(100, 180, Label, textValue, false)
        if(clear){
            Allocate(elements)
        }
    }

    void: updatePush(our dash: element) <- {
        elements.pushLast(element)
    }

    void: setPos(me GUI_Scalar:x, me GUI_Scalar:y, me GUI_Scalar: extCursor) <- {
        posIsSet <- true
        posX <- x;
        posY <- y;
        extC <- extCursor
        header.setPos(x, y, y)
        y <- y+header.height
        width <- header.width
        height <- y-posY
        extX <- header.extX
        extY <- max(y, extC)
        /*if(displayMode!=headerOnly){
            if(orientation==vertical){
                x <- x+8
                withEach element in elements{
                    element.dashParent <- self
                    element.isHidden <- false
                    element.setPos(x,y,extC)
                    y <- y+element.height
                    width <- max(width, element.width+8)
                    extX <- max(extX, element.extX)
                    extY <- max(extY, element.extY)
                }
                height <- y-posY
            } else if(orientation==horizontal){
                me GUI_Scalar: listX <- posX + header.width+30    // This 30 should really be calculated to compensate for nested items. Actual distance should be 40.
                me GUI_Scalar: listY <- extC
                me GUI_Scalar: listC <- extC+40;
                withEach element in elements{
                    element.dashParent <- self
                    element.isHidden <- false
                    element.setPos(listX,listY,listC)
                    extC  <- max(extC, element.extY)
                    extY  <- max(extY, extC)
                    listX <- element.extX + 20
                    extX  <- element.extX
                }
                addRelation("arrow", self, elements[0])
                if(extC > listC){
                    extC <- extC+40
                    extY <- max(extY, extC)
                }
            }
        }*/
    }

   me bool: primaryClick(their GUI_ButtonEvent: event) <- {
        me GUI_Scalar: eventX <- event.x
        me GUI_Scalar: eventY <- event.y
        if( header.isTouching(eventX, eventY)){
            if(displayMode==headerOnly){displayMode <- fullDisplay; orientation <- vertical}
            else if(displayMode==fullDisplay and orientation==vertical){
                orientation<-horizontal
            } else {displayMode <- headerOnly}
        } else {return(false)}
        return(true)
    }

    void: draw(their GUI_ctxt: cr) <- {
        if (isHidden){return()}
        header.isHidden <- false
        header.draw(cr)
        /*if(displayMode!=headerOnly){
            withEach element in elements{
                element.isHidden <- false
                element.draw(cr)
            }
            if(orientation==horizontal){
                me int:lastElIdx <- elements.size()
                if(lastElIdx>=1){
                    lastElIdx <- lastElIdx-1
                    cr.moveTo(elements[0].posX, elements[0].posY)
                    cr.lineTo(elements[lastElIdx].posX + elements[lastElIdx].width, elements[lastElIdx].posY)
                    cr.moveTo(elements[0].posX, elements[0].posY+18)
                    cr.lineTo(elements[lastElIdx].posX + elements[lastElIdx].width, elements[lastElIdx].posY+18)
                    cr.strokeNow()
                }
            }
        }*/
    }
}

struct DashboardWidget: inherits=Dashboard{
    their GUI_canvas: canvas
    their GUI_canvas: managedWidget
    me bool: showModalPopUp <- false
    me GUI_eventDispatcher: EventDispatcher
    our Dashboard: popUp

    their Dashboard: base  // This is bad. Fix calling super class then we won't need this.

    void: requestRedraw() <- {
        markDirtyArea(canvas, 0,0, widgetWidth(canvas), widgetHeight(canvas))
    }
    their DashboardWidget: getDashBrdMngr()<-{return(self)}
    their GUI_canvas: init(me string: label) <- {
        base <- self
        title   <- 'DashboardWidget.'+label
        showModalPopUp <- false
        canvas  <- thisApp.gui.newCanvas()
        canvas.setParent(self)
        width <- widgetWidth(canvas); height <- widgetHeight(canvas)
        //    their scrollerWidget:: scrollView  <- ()
        //    their GUI_ScrollingWindow: scrollerFrame <- scrollView.makeScrollerWidget(canvas)
        //    managedWidget <- scrollerFrame
        //    managedWidget <- makeYStack("")
        //    addToContainer(managedWidget, canvas)
        managedWidget <- canvas
        EventDispatcher.registerWidgetForEventDispatcher(canvas, self)
        return(managedWidget)
    }
    me bool: mouseMoved(their GUI_MotionEvent: event) <- {
        if(showModalPopUp){return(popUp.mouseMoved(event))}
        return(mouseMovedBase(event))
    }
    me bool: primaryClick(their GUI_ButtonEvent: event) <- {
        if(showModalPopUp){return(popUp.primaryClick(event))}
        return(basePrimaryClick(event))
    }
    me bool: secondaryClick(their GUI_ButtonEvent: event) <- {
        if(showModalPopUp){return(popUp.secondaryClick(event))}
        return(baseSecondaryClick(event))
    }
    me bool: primaryUp(their GUI_ButtonEvent: event) <- {
        if(showModalPopUp){return(popUp.primaryUp(event))}
        return(basePrimaryUp(event))
    }
    me bool: primaryDn(their GUI_ButtonEvent: event) <- {
        if(showModalPopUp){return(popUp.primaryDn(event))}
        return(basePrimaryDn(event))
    }
    void: activateModalPopup(our Dashboard: popupToShow)<-{
        popUp <- popupToShow
        showModalPopUp <- true
        requestRedraw()
    }
    void: closePopup()<-{
        showModalPopUp <- false
        popUp <- NULL
        requestRedraw()
    }
}
/////////////////////////////////////////////////////
// Structs for Proactive GUI
// This code is experimental and incomplete

struct GLOBAL{
    me GUI_Scalar: distanceBetween2Points(me GUI_Scalar: x1, me GUI_Scalar: y1, me GUI_Scalar: x2, me GUI_Scalar: y2) <- {
        me GUI_Scalar: deltaX <- abs(x2-x1)
        me GUI_Scalar: deltaY <- abs(y2-y1)
        return(sqrt(deltaX*deltaX + deltaY*deltaY))
    }
}

struct EventTrigger:inherits=<mode[tPrimaryClick, tSecondaryClick, tPrimaryUp, tPrimaryDn, tSecondaryUp, tSecondaryDn,
                                   tMouseMove, tMouseEnter, tMouseExit, tMouseHover, tDragStart, tKeyPress, tKeyUp, tKeyDn, tTimer
                                   // Add user or higher level trigger support
                                  ]> {}

struct EventType:inherits=<mode[eNullEvent, eNormalize, eAddInfon, eDeleteInfon, eEditString, eEditInt, eEditByType,
                                eMoveInfonInList, eMoveInfonToList,
                                eGUI_SetXY, eGUI_SetColor, eGUI_SetDragMode, eGUI_SetTimer, eGUI_setStr1, eGUI_setInt1,
                                eGUI_SetViewMode, eReqRedraw, eBlockEvents
                                // Add events for system events such as play_sound or fetch_file
                               ]> {}

struct GuiCoords{
    me GUI_Scalar: X  me GUI_Scalar: Y  me GUI_Scalar: W  me GUI_Scalar: H

    bool: isTouching(me GUI_Scalar: x, me GUI_Scalar: y) <- {
        return ((x >= X) and (x < X + W) and (y >= Y) and (y < Y + H))
    }
}

struct GuiDataRec{
    me string: str1
    me int64:  int1
    me int64:  int2
    me GuiCoords:coordinates
    me cdColor: color
    //me DragState

}

struct ProactEvent{
    me bool: done      // If done, don't repeat the action
    me EventTrigger: Trigger
    me GUI_Scalar: X
    me GUI_Scalar: Y
    me GUI_Scalar: W
    me GUI_Scalar: H
    me EventType: eventType
    me string: dataIdTag
    me string: text
    me int64: int1
    our POV: infonX
    our POV: infonY
    me GUI_Scalar: arg1
    me GUI_Scalar: arg2
    me GUI_Scalar: arg3
    me GUI_Scalar: arg4
    our dashDrawing: popupDR
    their cdColor: NewColor

    void: setTrigger(me EventTrigger: trigger, their GuiCoords:RA) <- {
        Trigger<-trigger; X<-RA.X; Y<-RA.Y; W<-RA.W; H<-RA.H;
    }
    void: setInfonEvent(me EventType: evntType, our POV:infon1, our POV:infon2) <- {eventType<-evntType; infonX<-infon1; infonY<-infon2;}
    void: setNormalizeEvent(me EventType: evntType, me string: query) <- {eventType<-evntType; text<-query;}
    void: setGUI_Event(me EventType: evntType, our infon: target, me GUI_Scalar: a1, me GUI_Scalar: a2, me GUI_Scalar: a3, me GUI_Scalar: a4) <- {
        eventType<-evntType; arg1<-a1; arg2<-a2; arg3<-a3; arg4<-a4; done <- false;
    }
    void: setGUI_Event1(me EventType: evntType)<-{eventType<-evntType; done <- false}
    void: setGUI_Store_Str1(me string: dataID, me string: strVal)<-{eventType<-eGUI_setStr1; dataIdTag<-dataID; text<-strVal; done <- false}
    void: setGUI_Store_Int1(me string: dataID, me int64: intVal)<-{eventType<-eGUI_setInt1; dataIdTag<-dataID; int1<-intVal; done <- false}
    //void: setGUI_popupEvent(our dashDrawing: dr)<-{eventType<-eGUI_PopupModal; popupDR<-dr; done <- false}
    void: setGUI_Color(me string: colorSlotID, their cdColor: newColor) <- {
        eventType<-eGUI_SetColor; text<-colorSlotID; NewColor<-newColor; done <- false;
    }

    bool: isTouching(me GUI_Scalar: x, me GUI_Scalar: y) <- {
        return ((x >= X) and (x < X + W) and (y >= Y) and (y < Y + H))
    }
}

struct Presenter{
    their GuiModelManager: modelMgr

    me List<our ProactEvent>: eventRegistry             // For events with a single target
    me List<our ProactEvent>: broadcastEventRegistry    // More than one target wants to know

    void: registerEvent(our ProactEvent: event) <- {eventRegistry.prepend(event)}
    void: registerBroadcastEvent(our ProactEvent: event) <- {broadcastEventRegistry.prepend(event)}
    void: reset() <- {eventRegistry.clear(); broadcastEventRegistry.clear()}

    // Returns true if mouse is currently over this.
    // Sets up the events to manage it.
    me bool: addMouseOverEvents(me GuiCoords:myCoords) <- {
        me bool: mouseIsOver <- myCoords.isTouching(crntMouseX, crntMouseY)
        our ProactEvent:: guiEvent;
        if(!mouseIsOver){ // Register to be notified when mouse enters
            guiEvent.setTrigger(tMouseMove, myCoords)
            guiEvent.setGUI_Event1(eReqRedraw)
            registerEvent(guiEvent)
        }else{  // Register to be notified when mouse has exited
            guiEvent.setTrigger(tMouseExit, myCoords)
            guiEvent.setGUI_Event1(eReqRedraw)
            registerBroadcastEvent(guiEvent)
        }
        return(mouseIsOver)
    }


    void: drawCircleButton(our dashDrawing: dr, me GUI_Scalar: posX, me GUI_Scalar: posY, me GUI_Scalar: radius, me GUI_Scalar: lineWidth, me string: symbol, me string: datasID) <- {
        me GuiCoords:myCoords{posX, posY, radius*2, radius*2}
        me bool: mouseIsOver <- addMouseOverEvents(myCoords)
        me cdColor: buttonColor
        if(mouseIsOver){buttonColor<-buttonBright} else {buttonColor<-buttonNormal}
        dr.addC(cmdSetColor, buttonColor)
        dr.add1(cmdRoundLineCap)
        dr.add2(cmdSetLineWidth, lineWidth)
       // cr.circle(posX + radius, posY + radius, radius)
        me GUI_Scalar: stickLen <- radius/3
        if (symbol=="+") {
            dr.addXY(cmdMoveTo, posX + radius, posY + radius/4)
            dr.addXY(cmdLineTo, posX + radius, posY + 7*radius/4)
            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius)
        }
        else if (symbol=="-") {
            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius)
        }
        else if (symbol=="<") {
            dr.addXY(cmdMoveTo, posX + radius, posY + radius - stickLen * sqrt(2.0))
            dr.addXY(cmdLineTo, posX + radius - stickLen * sqrt(2), posY + radius)
            dr.addXY(cmdMoveTo, posX + radius, posY + radius + stickLen * sqrt(2.0))
        }
        else if (symbol==">") {
            dr.addXY(cmdMoveTo, posX + radius, posY + radius - stickLen * sqrt(2.0))
            dr.addXY(cmdLineTo, posX + radius + stickLen * sqrt(2), posY + radius)
            dr.addXY(cmdLineTo, posX + radius, posY + radius + stickLen * sqrt(2.0))
        }
        else if (symbol=="v") {
            dr.addXY(cmdMoveTo, posX  - stickLen * sqrt(2.0), posY )
            dr.addXY(cmdLineTo, posX, posY + radius)
            dr.addXY(cmdLineTo, posX  + stickLen * sqrt(2.0), posY)
        }
        else if (symbol=="menu") {
            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius)

            dr.addXY(cmdMoveTo, posX + radius/4, posY + radius/4)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + radius/4)

            dr.addXY(cmdMoveTo, posX + radius/4, posY + 7*radius/4)
            dr.addXY(cmdLineTo, posX + 7*radius/4, posY + 7*radius/4)
        }
        dr.add1(cmdStroke)
        dr.add1(cmdEdgedLineCap)
    }
me int: GV_LeftRight_Pad <- 5
me int: GV_innerVert_Pad <- 5
me int: GV_innerHorz_Pad <- 5
me int: GV_topBottom_Pad <- 5

    void: draw_X_stack_XYwh(our dashDrawing: dr, our POV: data, me GUI_Scalar: posX, me GUI_Scalar: posY, their GUI_Scalar: width, their GUI_Scalar: height, me string: viewModeHint) <- {
        // Draw the list body
        me GUI_Scalar: xCur <- posX
        me GUI_Scalar: maxH <- 0
        me int: count<- 0
        withEach element in data.pItem.value.items{
            if(count>0){xCur <+- GV_innerHorz_Pad}
            dr.addC(cmdSetColor, surfaceBkgnd)
            our dashDrawing:: dr2
            me GUI_Scalar: W2
            me GUI_Scalar: H2
            drawUnsizedElement(dr2, element, xCur, posY, W2, H2, viewModeHint)
            maxH <- max(maxH, H2)
            dr.add1(cmdFill)
            dr.addSubDrawing(dr2)
            xCur <+- vertListWidth
            count <+- 1
        }
        height <deep- maxH
        width  <deep- xCur-posX
    }
    void: draw_Y_stack_XYWh(our dashDrawing: dr, our POV: data, me GUI_Scalar: posX, me GUI_Scalar: posY, me GUI_Scalar: width, their GUI_Scalar: height, me string: viewModeHint) <- {
        // Draw the list body
        me GUI_Scalar: yCur <- posY+GV_topBottom_Pad
        me int: count<- 0
        withEach element in data.pItem.value.items{
            if(count>0){yCur <+- GV_innerVert_Pad}
            dr.addC(cmdSetColor, surfaceBkgnd)
            me GUI_Scalar: itemHeight
            drawUnsizedElement(dr, element, posX+GV_LeftRight_Pad, yCur, width-(GV_LeftRight_Pad*2), itemHeight, viewModeHint)
            yCur <+- itemHeight
            count <+- 1
        }
        yCur <+- GV_topBottom_Pad
        height <deep- yCur-posY   // return the height
    }
}

struct GuiModelManager{
    me Map<me string, our GuiDataRec>: guiData
    our GuiDataRec: fetchGuiData(me string: itemID) <-{
        itr Map<me string, our GuiDataRec>: it <- guiData.find(itemID)
        if(it == guiData.end()){return(NULL)}
        return(it.val)
    }

    me cdColor: getColor(me string: dataID, their cdColor: Default) <- {
        our GuiDataRec: result <- fetchGuiData(dataID)
        if(result==NULL){return(Default)}
        return(result.color)
    }
    me GuiCoords: getCoordinates(me string: dataID, their GuiCoords: Default) <- {
        our GuiDataRec: result <- fetchGuiData(dataID)
        if(result==NULL){return(Default)}
        return(result.coordinates)
    }
    me bool: getBool(me string: dataID, me bool: Default) <- {
        our GuiDataRec: result <- fetchGuiData(dataID)
        if(result==NULL){return(Default)}
        return(result.int1 != 0)
    }
    me bool: getInt64(me string: dataID, me int64: Default) <- {
        our GuiDataRec: result <- fetchGuiData(dataID)
        if(result==NULL){return(Default)}
        return(result.int1)
    }
    me string: getString(me string: dataID, me string: Default) <- {
        our GuiDataRec: result <- fetchGuiData(dataID)
        if(result==NULL){return(Default)}
        return(result.str1)
    }

    void: sendSaveSignal() <- {log("TODO: Request and save the model")}
}

struct ProactiveGUI{
    me Presenter: presenter
    me GuiModelManager: guiModelManager

    none:ProactiveGUI() <- {
        presenter.modelMgr <- guiModelManager
    }
}
struct DrawCmd:inherits=<mode[cmdMoveTo, cmdLineTo, cmdDrawRect, cmdRoundRect, cmdRoundTopRect, cmdRoundBotRect,
                                 cmdRenderText, cmdRenderTextCentered, cmdDrawImage, cmdDrawBkgndImage,
                                 cmdDrawCircle, cmdSetColor, cmdSetLineWidth, cmdRoundLineCap, cmdEdgedLineCap,
                                 cmdFill, cmdStroke, cmdSubDrawing
                             ]> {}

struct Drawel{
    DrawCmd: cmd
    me GUI_Scalar: x
    me GUI_Scalar: y
    me GUI_Scalar: w
    me GUI_Scalar: h
    me GUI_Scalar: arg1
    me GUI_Scalar: arg2
    me string: text
    their fontSpec: font
    our dashDrawing: drawing

    void: render(their GUI_ctxt: cr)<-{
        //log("CMD:"+DrawCmdStrings[cmd]+" x:"+toString(x)+" y:"+toString(y)+" w:"+toString(w)+" h:"+toString(h)+" :"+text)
        switch(cmd){
        case cmdMoveTo:         {cr.moveTo(x,y)}
        case cmdLineTo:         {cr.lineTo(x,y)}
        case cmdDrawRect:       {cr.rectangle(x,y,w,h)}
        case cmdRoundRect:      {roundedRectangle(cr, x,y,w,h, arg1)}
        case cmdRoundTopRect:   {roundedTopRect(cr, x,y,w,h, arg1)}
        case cmdRoundBotRect:   {roundedBotmRect(cr, x,y,w,h, arg1)}
        case cmdRenderText:     {renderText(cr, text, font, x, y)}
        case cmdRenderTextCentered: {renderTextCentered(cr, text, font, x, y)}
        case cmdDrawImage:      {displayImage(cr, text, x, y, arg1)}
        case cmdDrawBkgndImage: {displayBackgroundImage(cr, text)}
        case cmdFill:           {cr.fillNow()}
        case cmdStroke:         {cr.strokeNow()}
        case cmdDrawCircle:     {cr.circle(x,y,arg1)}
        case cmdSetColor:       {cr.setRGBA(x,y,w,h)}
        case cmdSetLineWidth:   {cr.setLineWidth(x)}
        case cmdRoundLineCap:   {cr.setRoundLineCap()}
        case cmdEdgedLineCap:   {cr.setEdgedLineCap()}
        case cmdSubDrawing:     {drawing.render(cr)}
        }
    }
}

struct dashDrawing{
    me List<our Drawel>: cmds

    our Drawel: add1(me DrawCmd: dCmd) <-{our Drawel:: drl; drl.cmd<-dCmd; cmds.pushLast(drl); return(drl)}
    our Drawel: add2(me DrawCmd: dCmd, me GUI_Scalar: X) <-{our Drawel:: drl; drl.x<-X; drl.cmd<-dCmd; cmds.pushLast(drl); return(drl)}
    our Drawel: addXY(me DrawCmd: dCmd, me GUI_Scalar: X, me GUI_Scalar: Y) <-{our Drawel:: drl; drl.cmd<-dCmd; drl.x<-X drl.y<-Y; cmds.pushLast(drl); return(drl)}
    our Drawel: addT(me DrawCmd: dCmd, me string: T) <-{our Drawel:: drl; drl.cmd<-dCmd; drl.text<-T; cmds.pushLast(drl); return(drl)}
    our Drawel: addC(me DrawCmd: dCmd, me cdColor: C) <-{our Drawel:: drl{C.red,C.green,C.blue,C.alpha}; drl.cmd<-dCmd; cmds.pushLast(drl); return(drl)}
    our Drawel: addRA(me DrawCmd: dCmd, their GuiCoords:RA) <-{our Drawel:: drl{RA.X, RA.Y, RA.W, RA.H}; drl.cmd<-dCmd; cmds.pushLast(drl); return(drl)}
    our Drawel: addRAA(me DrawCmd: dCmd, their GuiCoords:RA, me GUI_Scalar: ARG) <-{our Drawel:: drl{RA.X,RA.Y,RA.W,RA.H,ARG}; drl.cmd<-dCmd; cmds.pushLast(drl); return(drl)}
    our Drawel: addTF(me DrawCmd: dCmd, me GUI_Scalar: X, me GUI_Scalar: Y, me string: T, their fontSpec: F) <-{our Drawel:: drl; drl.cmd<-dCmd; drl.x<-X drl.y<-Y; drl.text<-T; drl.font<-F; cmds.pushLast(drl); return(drl)}
    our Drawel: addSubDrawing(our dashDrawing: D)<-{our Drawel:: drl; drl.cmd<-cmdSubDrawing; drl.drawing<-D; cmds.pushLast(drl); return(drl)}

    me void: render(their GUI_ctxt: cr) <- {
        withEach cmd in cmds{
            cmd.render(cr)
        }
    }
}

struct ProactiveGUIWidget: inherits=DashboardWidget{
    me GUI_Scalar: pointerDragThreshold <- 10

    me bool: primaryBtnIsDown
    me GUI_Scalar: primaryButtonDownX
    me GUI_Scalar: primaryButtonDownY
    me bool: currentlyDraggingPointer
    our infon: dragInfonTargetX
    our infon: dragInfonTargetY
    me GUI_Scalar: preDragX
    me GUI_Scalar: preDragY

    void: updateReferencedVars(me GUI_Scalar: argA, me GUI_Scalar: argB) <- {
        dragInfonTargetX.value.num <- preDragX+(argA-primaryButtonDownX) // ref1 <- argA
        dragInfonTargetY.value.num <- preDragY+(argB-primaryButtonDownY) // ref2 <- argB
        requestRedraw()
        //log("DRAG X:"+toString(argA-primaryButtonDownX) + "  Y:"+toString(argB-primaryButtonDownY))
    }
    void: fetchVariableReference(our infon: numInfonX, our infon: numInfonY) <- {
        dragInfonTargetX <- numInfonX
        dragInfonTargetY <- numInfonY
        preDragX <- numInfonX.fetchDouble()
        preDragY <- numInfonY.fetchDouble()
    }

    void: clearVariableReference() <- {
        dragInfonTargetX <- NULL
        dragInfonTargetY <- NULL
    }

    void: cancelDragOperation() <- {
        currentlyDraggingPointer <- false
        updateReferencedVars(primaryButtonDownX, primaryButtonDownY)
        clearVariableReference()
    }


    our ProactEvent: findEventUnderCursor(me EventTrigger: trgrFound, me GUI_Scalar: eventX, me GUI_Scalar: eventY) <- {
        withEach eventNode in proactiveGUI.presenter.eventRegistry{
            if(eventNode.Trigger==trgrFound){
                if(eventNode.isTouching(eventX, eventY)){
                    return(eventNode)
                }
            }
        }
        return(NULL)
    }

    me void: lookForDragStartEvent(me GUI_Scalar: eventX, me GUI_Scalar: eventY) <- {
        our ProactEvent: eventNode <- findEventUnderCursor(tDragStart, eventX, eventY)
        if(eventNode){
            currentlyDraggingPointer <- true
            fetchVariableReference(eventNode.infonX.pItem, eventNode.infonY.pItem)
            updateReferencedVars(eventX, eventY)
        }
    }

    void: checkBroadcastEvents(me EventTrigger: trgr, me GUI_Scalar: X, me GUI_Scalar: Y) <- {
        withEach eventNode in proactiveGUI.presenter.broadcastEventRegistry{
            if(eventNode.Trigger==trgr){
                if(!eventNode.isTouching(X, Y)){
                    proactiveGUI.guiModelManager.processCommand(eventNode)
                }
            }
        }
    }

    me bool: mouseMoved(their GUI_MotionEvent: event) <- {
        me bool: retVal <- false
        crntMouseX <- event.x
        crntMouseY <- event.y
        if(primaryBtnIsDown){
            if(currentlyDraggingPointer){
                updateReferencedVars(crntMouseX, crntMouseY)
            } else {
                me GUI_Scalar: distanceMoved <- distanceBetween2Points(primaryButtonDownX, primaryButtonDownY, crntMouseX, crntMouseY)
                if(distanceMoved>pointerDragThreshold){
                    lookForDragStartEvent(crntMouseX, crntMouseY)
                }
            }
            retVal <- true
        } else {
            //log("Registry: A:"+toString(proactiveGUI.presenter.eventRegistry.size())+" B:"+toString(proactiveGUI.presenter.broadcastEventRegistry.size()) +"   X:"+toString(crntMouseX) +"   Y:"+toString(crntMouseY))
            our ProactEvent: eventNode <- findEventUnderCursor(tMouseMove, event.x, event.y)
            if(eventNode){
                if(!eventNode.done){
                    proactiveGUI.guiModelManager.processCommand(eventNode)
                    eventNode.done <- true
                }
                retVal <- true
            }
            //log("Registry2_size:"+toString(proactiveGUI.presenter.broadcastEventRegistry.size()))
            checkBroadcastEvents(tMouseExit, event.x, event.y)
        }
        return(retVal)
    }

    me bool: primaryUp(their GUI_ButtonEvent: event) <- {
        primaryBtnIsDown <- false
        if(currentlyDraggingPointer){
            if(event.x != crntMouseX  or  event.y != crntMouseY){
                crntMouseX <- event.x
                crntMouseY <- event.y
                updateReferencedVars(crntMouseX, crntMouseY)
            }
            currentlyDraggingPointer <- false
            proactiveGUI.guiModelManager.sendSaveSignal()
            clearVariableReference()
            return(true)
        } else{
            our ProactEvent: eventNode <- findEventUnderCursor(tPrimaryUp, event.x, event.y)
            if(eventNode){
                proactiveGUI.guiModelManager.processCommand(eventNode)
                return(true)
            }
        }
        return(false)
    }
    me bool: primaryDn(their GUI_ButtonEvent: event) <- {
        primaryBtnIsDown <- true
        primaryButtonDownX <- event.x
        primaryButtonDownY <- event.y
    }
    me bool: primaryClick(their GUI_ButtonEvent: event) <- {
        me bool: retval <- false
        our ProactEvent: eventNode <- findEventUnderCursor(tPrimaryClick, event.x, event.y)
        if(eventNode){
            proactiveGUI.guiModelManager.processCommand(eventNode)
            retval <- true
        }
        checkBroadcastEvents(tPrimaryClick, event.x, event.y)
        return(retval)
    }

    me bool: secondaryClick(their GUI_ButtonEvent: event) <- {
        if(currentlyDraggingPointer){
            cancelDragOperation()
            return(true)
        } else {
            our ProactEvent: eventNode <- findEventUnderCursor(tSecondaryClick, event.x, event.y)
            if(eventNode){
                proactiveGUI.guiModelManager.processCommand(eventNode)
                return(true)
            }
        }
        return(false)
    }

    their GUI_canvas: initProactiveGUI() <- {
        primaryBtnIsDown <- false
        currentlyDraggingPointer <- false
        return(init("ProactiveGUI"))
    }

}

struct GLOBAL{
    me GUI_Scalar: crntMouseX
    me GUI_Scalar: crntMouseY

    me GUI_Scalar: intersectPoint(me GUI_Scalar:outsidePt, me GUI_Scalar:smallPt, me GUI_Scalar: largePt) <- {
        me GUI_Scalar: ret
        if(outsidePt<smallPt){ret<-smallPt}
        else if(outsidePt>largePt){ret<-largePt}
        else{ret<-outsidePt}
        return(ret)
    }
}
