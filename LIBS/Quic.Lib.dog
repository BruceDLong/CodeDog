// Quic

requirements = [
    [require, Quic_implementation]
]

LibDescription ={
    useStatus   = static
    description ='Interface to the quic protocol'
}

initCode = `
    initQuicSystem()
`

deinitCode = `
    deinitQuicSystem()
`
featuresNeeded = [Logger,IOBuffer]

struct GLOBAL{
    const int: bufSize <- 1024
    me int: lastTaskID <- 0
}
struct QuicConnectionID{}

struct QuicEngine{
    me List<our QProtocol>: protocols
    me bool: isServer

    void: init(me string: filenameTag, me bool: ServerMode, me string: ipAddr, me int:portNum)
    void: start()

    void: onNewConnection_CB(their QuicConnection: qConn) <- {print("BASE::onNewConnection_CB!!!!!!!!!!!!!!!!!\n")}
    their QuicConnection: allocNewConn() // Just allocate and return your descendent of QuicConnection
    void: addProtocol(our QProtocol: QP) <- {protocols.pushLast(QP)}

    // setMaxStreams()
    // setStreamLimits()
    // setConnectionLimits()
}

struct QuicConnection{
    their QuicEngine:  myEngine

    void: onNewStream_CB(their QuicStream: stream) <- {print("BASE QuicConnection::onNewStream_CB!!!!!!!!!!!!!!!!!\n")}
    void: onConnectionClosed_CB()                  <- {print("BASE::onConnectionClosed_CB!!!!!!!!!!!!!!!!!\n")}
    their QuicConnectionID: getConnectionID()
    their QuicStream: allocNewStream()             <- {print("BASE::allocNewStream!!!!!!!!!!!!!!!!!\n"); return(0)} // Just allocate and return your descendent of QuicStream
    void: abort()
    //void: ping()

    // on_reset_CB()
    // on_handshakeDone_CB()
    // on_sess_resume_info_CB()
    // getConnectionStatus()
}

struct QuicStream{
    their QuicConnection: myConnection
    me string: buff     // TODO: add buffer class to CodeDog
    me string: readBuffer     // TODO: add buffer class to CodeDog

    /// onRead_CB() is used to read incoming data. Take data from the string: data. Return the number of bytes you used.
    /// As long as you keep using the entire buffer, onRead_CB() will keep getting called as new data comes in.
    /// If you do not use all of them (and return a number < data.size()) it will stop looping. onRead_CB() still may be called again
    /// if you have requestRead on. So if you are done reading, unSet readRequest until you are ready for more.
    /// If 'finished' is true it means this is the last buffer due to end-of-stream.
    /// If you use all the bytes and finished is true the input stream will be stopped.
    uint64: onRead_CB (their QuicStream: qStream, their string: data, me bool: finished)
    void: onWrite_CB(their QuicStream: qStream)
    void: onClose_CB(their QuicStream: qStream) <- {}

    void: nextOpIsRead()
    void: nextOpIsWrite()
    void: close()
    me int: read(me string: buf)
    me int: write(me string: buf)
    void: setPriority(me 1..256: priority)  // Lower value  = higher priority
    void: flushStream()
    void: stopReading()
    void: stopWriting()
    their QuicConnection: getConnection()

    me bool: readNotDone
    our QProtocol: crntProtocol

    me uint64: readLine(me string:dataIn) <- { // Returns the number of bytes used.
        me uint64: bytesUsed <- 0
        if(!readNotDone){
            readNotDone <- true
            readBuffer  <- ""
        }
        bytesUsed <- dataIn.find("\n")
        if(bytesUsed<0){
            readBuffer <+- dataIn
            bytesUsed <- dataIn.size()
        }else{
            readNotDone <- false
            readBuffer <+- dataIn.subStr(0, bytesUsed)
            bytesUsed <+- 1
        }
        return(bytesUsed)
    }
    void: INIT() <- {
        withEach n in RANGE(0..16){buff <+- "1234567890123456789012345678901234567890123456789012345678901234"}
    }
}
/////////////////////////////
// Engine sub-classes for Client and Server mode + Generic protocols
struct QProtocol{
    mode[qREQ, qSRV]: role
    mode[qOK, qError, qTerminated]: status
    me int: step
    me string: taskDescription
    me string: protocolIDPrefix
    me string: taskID
    me string: protocolArgs

    me bool: checkProtocolID(me string: protocol) <-{return(false)}
    their QuicStream: myStream
    void: init() <- {}
    void: terminateStream() <- {}
    our QProtocol: createClone()
    uint64: onServerRead(their QuicStream: qStream, their string: data, me bool: finished)
    bool: onServerWrite(their QuicStream: qStream)
    uint64: onClientRead(their QuicStream: qStream, their string: data, me bool: finished)
    bool: onClientWrite(their QuicStream: qStream)
    void: onNewStream_CB(their QuicStream: stream) <- {print("BASE QProtocol::onNewStream_CB!!!!!!!!!!!!!!!!!\n")}
    me string: serverInit(me string: argsStr, their QuicStream: stream)
    void: clientInit(me string: argsStr)
}

// SERVER
struct QuicEngine_Server: inherits=QuicEngine{
    our QProtocol: chooseProtocol(me string: protocolID) <- {
        withEach protocol in protocols{
            if(protocolID==protocol.protocolIDPrefix){
                our QProtocol: newProt <- protocol.createClone()
                return(newProt)
            }
        }
        return(NULL)
    }
    void: onNewConnection_CB(their QuicConnection: qConn) <- {
        log("created new connection");
    }
    their QuicConnection: allocNewConn() <- {their QuicConnection_Server:: retval; return(retval);}
}
struct QuicConnection_Server: inherits=QuicConnection{
    void: onConnectionClosed_CB() <- {log("server closed connection")}

    void: onNewStream_CB(their QuicStream: qStream) <- {
        me uint64: streamID <- qStream.getStreamID()
        print("QuicConnection_Server::onNewStream_CB() STREAM_ID: ",streamID,"\n")
        if(streamID==0){
            qStream.nextOpIsRead()
            //qStream.crntProtocol.onNewStream_CB(qStream)
        }
        else{

        }

    }

    their QuicStream: allocNewStream() <- {their QuicStream_Server:: retval; return(retval);}
}
struct QuicStream_Server: inherits=QuicStream{
    uint64: onRead_CB(their QuicStream: qStream, their string: data, me bool: finished) <- {
        me uint64: bytesUsed <- 0
        print("\nSERVER::onRead_CB:","  STREAM_ID:",qStream.getStreamID(),"\n")
        if(crntProtocol==NULL){
            bytesUsed <- qStream.readLine(data); if(readNotDone){return(bytesUsed)}
            me string: taskDescriptionIn  <- readBuffer
            me int: colPos      <- taskDescriptionIn.find(":")
            me string: protocolIDIn <- taskDescriptionIn.subStr(0, colPos)
            taskDescriptionIn   <- taskDescriptionIn.subStr(colPos+1, taskDescriptionIn.size())
            me string: taskIDIn <- taskDescriptionIn.subStr(0, colPos+1)
            colPos <- taskDescriptionIn.find(":")
            me string: protocolArgsIn   <- taskDescriptionIn.subStr(colPos+1, taskDescriptionIn.size())
            their QuicEngine_Server: QEng <- myConnection.myEngine
            crntProtocol <- QEng.chooseProtocol(protocolIDIn)
            if(crntProtocol==NULL){
                LOGX("Protocol not found:'%s'", protocolIDIn)
                their QuicConnection: qConn <- getConnection()
                qConn.abort()
                return(0) // Signal to stop sending read events for now.
            }else{
                crntProtocol.myStream <- qStream
                crntProtocol.taskDescription  <- taskDescriptionIn
                crntProtocol.protocolIDPrefix <- protocolIDIn
                crntProtocol.taskID           <- taskIDIn
                crntProtocol.protocolArgs     <- protocolArgsIn
                crntProtocol.step             <- 0
                me string: serverInitStr <- crntProtocol.serverInit(protocolArgsIn, qStream)
                print("serverInitStr:",serverInitStr,"\n")
                qStream.write(serverInitStr)
            }
        }
        bytesUsed <+- crntProtocol.onServerRead(qStream, data, finished)
        return(bytesUsed)
    }
    void: onWrite_CB(their QuicStream: qStream) <- {
        if(!qStream.crntProtocol.onServerWrite(qStream)){
            qStream.stopWriting()
            qStream.nextOpIsRead()
        }
    }
    void: onClose_CB(their QuicStream: qStream) <- <%{
        LOGX("stream closed");
    }%>
}

// CLIENT
struct QuicEngine_Client: inherits=QuicEngine{
    void: onNewConnection_CB(their QuicConnection: qConn) <- {}

    their QuicConnection: allocNewConn() <- {their QuicConnection_Client:: retval; return(retval);}
    their QuicConnection_Client: makeClientConnection(me string: ipAddr, me string:portNum)
}
struct QuicConnection_Client: inherits=QuicConnection{
    me List<our QProtocol>: clientProtocols

    void: addProtocol(our QProtocol: QP) <- {
        QP.step <- 0
        clientProtocols.pushLast(QP)
        print("!!!! ADD PROTOCOL: ", clientProtocols.size(), "\n")
    }
    void: onConnectionClosed_CB() <- {
        LOGX("SLIP:C3 client connection closed");
    }
    void: onNewStream_CB(their QuicStream: qStream) <- {
        me uint64: streamID <- qStream.getStreamID()
        print("QuicConnection_CLIENT::onNewStream_CB() STREAM_ID:", streamID, "\n")
        their QuicStream_Client: qStreamClient  <- qStream
        their QuicEngine_Client: qcEngine <- myEngine
        if(streamID==0){
            if(clientProtocols.size()==0){printf("ERROR: No protocls given for Quic.\n"); exit(1);}
            qStreamClient.nextOpIsWrite()
            qStreamClient.crntProtocol <- clientProtocols[0]
            qStreamClient.crntProtocol.myStream <- qStream
            qStreamClient.crntProtocol.init()
            clientProtocols.popFirst()
            qStreamClient.crntProtocol.onNewStream_CB(qStream)
        }
    }
    their QuicStream: allocNewStream() <- {
        their QuicStream_Client:: retval;
        return(retval);
    }
}
struct QuicStream_Client: inherits=QuicStream{
    their strBuf: readBuffer
    uint64: onRead_CB(their QuicStream: qStream, their string: data, me bool: finished) <- {
        me uint64: bytesUsed <- qStream.crntProtocol.onClientRead(qStream, data, finished)
        return(bytesUsed)
    }
    void: onWrite_CB(their QuicStream: qStream) <- {
        if(!qStream.crntProtocol.onClientWrite(qStream)){
            qStream.stopWriting()
            qStream.nextOpIsRead()
        }
    }
    void: onClose_CB(their QuicStream: qStream) <- {LOGX("SLIP:C6 stream closed");}
}
