//############  Add GUI-Toolkit features using GTK3
requirements = [
    [tagOneOf, Platform, [Linux]]
]

interface={
    provides=[GUI_ToolKit_implementation]
    libFiles=[`pkg-config --cflags --libs gtk+-3.0`]
    headers=[gtk/gtk.h, cairo-pdf.h]
}

LibDescription ={
    useStatus   = dynamic
    description ='GTK is a GUI Toolkit'
    features    =[GUI_ToolKit, Mouse, Keyboard, Audio]
    platforms   =[Linux]
    bindings    =[C, CPP]
    CPUs        =[i386, amd64, arm7]
}

initCode = `
    GUI_threads_messagePasser <- threadsMesgPasser()
`

/////////////////////////////////  STRUCT CONVERTERS
struct GUI_rect{me double: x1 me double: y1 me double: x2 me double: y2}
struct GUI_offset: wraps = GtkAdjustment ownerMe = their{}
struct GUI_item: wraps = GtkWidget ownerMe = their{}
struct GUI_Frame: wraps = GtkWidget ownerMe = their{}
struct GUI_menuBar: wraps = GtkWidget ownerMe = their{}
struct GUI_menu: wraps = GtkWidget ownerMe = their{}
struct GUI_menuItem: wraps = GtkWidget ownerMe = their{}
struct GUI_container: wraps = GtkContainer ownerMe = their{}
struct GUI_ScrollingWindow: wraps = GtkWidget ownerMe = their{}
struct GUI_VerticalScroller: wraps = GtkWidget ownerMe = their{}
struct INK_Image: wraps = cairo_surface_t ownerMe = their{}      // How will the ink look?
struct GUI_callback: wraps = GCallback ownerMe = their{}
struct GUI_Scalar: wraps = int{}
struct listWidget: wraps = GtkWidget ownerMe = their{}
struct GUI_XStack: wraps = GtkWidget ownerMe = their{}
struct GUI_YStack: wraps = GtkWidget ownerMe = their{}
struct GUI_Text: wraps = GtkWidget ownerMe = their{}
struct GDK_KEY_Down: wraps = GtkWidget ownerMe = their{}
struct GUI_ZStack: wraps = GtkWidget ownerMe = their{}
/////////////////////////////////  WIDGETS
struct GUI_storyBoard{
    their GtkWidget: GUI_storyBoard
    me void: addPane(their GUI_Frame: frame) <- <%!gtk_stack_add_named((GtkStack*)%0, (GtkWidget*)%1, %2)%>
}

struct boolWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_Frame: box
    their GUI_Label: dataLabel
    their GUI_Bool:  dataValue

    me bool: getValue()            <- {return(dataValue.getValue())}
    void: setValue(me bool: value) <- {dataValue.setValue(value)}
    me void: clear() <- {
        dataValue.setValue(true)
    }
    their GUI_Frame: initWidget(me string: name)  <- <%{
        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        dataLabel = gtk_label_new(name.data());
        gtk_label_set_width_chars((GtkLabel*)dataLabel, 15);
        gtk_label_set_xalign((GtkLabel*)dataLabel, 0.9);
        gtk_container_add(GTK_CONTAINER (box), dataLabel);
        dataValue = gtk_check_button_new();
        gtk_container_add(GTK_CONTAINER (box), dataValue);
        return box;
    }%>
}
struct intWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_Frame: box
    their GUI_Label: dataLabel
    their GUI_Text:  dataValue
    me double: initialValue  <- 0
    me double: minValue      <- -1000
    me double: maxValue      <- 1000
    me double: stepIncrement <- 1
    me double: pageIncrement <- 10
    me double: pageSize      <- 10
    me double: climbRate     <- 1
    me int:    decimalPlaces <- 0

    me int: getValue() <- <%{
        return(atoi(gtk_entry_get_text((GtkEntry*)dataValue)));
    }%>
    me void: setValue(me int: value) <- <%{
        gtk_entry_set_text((GtkEntry*)dataValue, to_string(value).data());
    }%>
    me void: clear() <- <%{
        gtk_entry_set_text((GtkEntry*)dataValue, "");
    }%>
    their GUI_Frame: initWidget(me string: name)  <- <%{
        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        dataLabel = gtk_label_new(name.data());
        gtk_label_set_width_chars((GtkLabel*)dataLabel, 15);
        gtk_label_set_xalign((GtkLabel*)dataLabel, 0.9);
        gtk_container_add(GTK_CONTAINER (box), dataLabel);
        dataValue = gtk_entry_new();
        gtk_container_add(GTK_CONTAINER (box), dataValue);
        gtk_widget_show_all (box);
        return box;
    }%>
}
struct intRangeWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_Frame: box
    their GUI_Label: dataLabel
    their GUI_Text:  dataValue
    me double: initialValue  <- 0
    me double: minValue      <- -1000
    me double: maxValue      <- 1000
    me double: stepIncrement <- 1
    me double: pageIncrement <- 10
    me double: pageSize      <- 10
    me double: climbRate     <- 1
    me int:    decimalPlaces <- 0

    me int: getValue() <- <%!gtk_spin_button_get_value_as_int ((GtkSpinButton*)%0->dataValue)%>
    me void: setValue(me int: val) <- <%!gtk_spin_button_set_value ((GtkSpinButton*)%0->box, %1)%>
    //me void: clear() <- <%{}%>

    their GUI_Frame: initWidget(me string: name)  <- <%{
        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        dataLabel = gtk_label_new(name.data());
        gtk_label_set_width_chars((GtkLabel*)dataLabel, 15);
        gtk_label_set_xalign((GtkLabel*)dataLabel, 0.9);
        gtk_container_add(GTK_CONTAINER (box), dataLabel);
        GtkAdjustment *adjustment = gtk_adjustment_new (initialValue,minValue,maxValue,stepIncrement,pageIncrement,pageSize);
        dataValue = gtk_spin_button_new(adjustment, climbRate, decimalPlaces);
        gtk_container_add(GTK_CONTAINER (box), dataValue);
        return box;
    }%>
}
struct stringWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_Frame: box
    their GUI_Label: dataLabel
    their GUI_Text:  dataValue

    me string: getValue() <- <%{
        return(gtk_entry_get_text((GtkEntry*)dataValue));
    }%>
    me void: setValue(me string: value) <- <%{
        gtk_entry_set_text((GtkEntry*)dataValue, value.data());
    }%>
    me void: clear() <- <%{
        gtk_entry_set_text((GtkEntry*)dataValue, "");
    }%>
    their GUI_Frame: initWidget(me string: name) <- <%{
        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        dataLabel = gtk_label_new(name.data());
        gtk_label_set_width_chars((GtkLabel*)dataLabel, 15);
        gtk_label_set_xalign((GtkLabel*)dataLabel, 0.9);
        gtk_container_add(GTK_CONTAINER (box), dataLabel);
        dataValue = gtk_entry_new();
        g_signal_connect(G_OBJECT(dataValue), "changed", G_CALLBACK(stringWidget_onChanged_CB), this);
        gtk_container_add(GTK_CONTAINER (box), dataValue);
        gtk_widget_show_all (box);
        return box;
    } %>
}
struct dateWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_Frame: box
    their GUI_Label: dataLabel
    their GtkWidget:  dataValue

    me timeValue: getValue() <- <%{
        guint year;
        guint month;
        guint day;
        gtk_calendar_get_date ((GtkCalendar*)dataValue,&year,&month,&day);
        int64_t retVal = unicodeMgr.epocTimeFromDateTime(year, month, day, 0, 0, 0);
        return(retVal);
    }%>
    me void: setValue(me timeValue: val) <- <%{
        DateTimeFields dateTimeFields;
        unicodeMgr.dateTimeFromEpocTime(val, &dateTimeFields);
        guint year = dateTimeFields.year;
        guint month = dateTimeFields.month;
        guint day = dateTimeFields.day;
        gtk_calendar_select_month((GtkCalendar*)dataValue, month+1, year);
        gtk_calendar_select_day((GtkCalendar*)dataValue, day);
        //cout<<"Set DATE:"<< year << " / " <<  month+1 << " / " << day  <<"\n"<<flush;
    }%>
    me void: clear() <- <%{
        gtk_calendar_clear_marks ((GtkCalendar*)dataValue);
    }%>
    their GUI_Frame: initWidget(me string: name)  <- <%{
        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        dataLabel = gtk_label_new(name.data());
        gtk_label_set_width_chars((GtkLabel*)dataLabel, 15);
        gtk_label_set_xalign((GtkLabel*)dataLabel, 0.9);
        gtk_container_add(GTK_CONTAINER (box), dataLabel);
        dataValue = gtk_calendar_new();
        g_signal_connect(G_OBJECT(dataValue), "day-selected", G_CALLBACK(dateWidget_onChanged_CB), this);
        gtk_container_add(GTK_CONTAINER (box), dataValue);
        return box;
    }%>
}
struct enumWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_Frame: box
    their GUI_Label: dataLabel
    their GtkWidget: dataValue
    me string[list]: options

    me int: getValue() <- <%!gtk_combo_box_get_active((GtkComboBox*)%0->dataValue)%>
    me void: setValue(me int: val) <- <%!gtk_combo_box_set_active((GtkComboBox*)%0->dataValue, %1)%>
    me void: clear() <- <%{}%>
    their GUI_Frame: initWidget(me string: label, me string[list]: Options)  <- <%{
        options = Options;
        box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        dataLabel = gtk_label_new(label.data());
        gtk_label_set_width_chars((GtkLabel*)dataLabel, 15);
        gtk_label_set_xalign((GtkLabel*)dataLabel, 0.9);
        gtk_container_add(GTK_CONTAINER (box), dataLabel);
        dataValue = gtk_combo_box_text_new();
        g_signal_connect(G_OBJECT(dataValue), "changed", G_CALLBACK(enumWidget_onChanged_CB), this);
        int idx=0;
        for (string option : options){
            gtk_combo_box_text_append((GtkComboBoxText*)dataValue, to_string(idx).data(), option.data());
            idx+=1;
        }
        gtk_container_add(GTK_CONTAINER (box), dataValue);
        return box;
    }%>
}
struct DateWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_Entry:    yearBox
    their GUI_ComboBox: monthBox
    their GUI_ComboBox: dayBox

    me timeValue: getValue() <- {
        me timeValue: tempYear  <- yearBox.getValueAsInt()
        me timeValue: tempMonth <- monthBox.comboBoxGetActive()+1
        me timeValue: tempDay   <- dayBox.comboBoxGetActive()+1
        me timeValue: dateVal   <- unicodeMgr.epocTimeFromDateTime(tempYear, tempMonth, tempDay, 0, 0, 0)
        print ("GET-DATE Y/M/D = TOTAL: ", tempYear, " / ", tempMonth, " / ", tempDay, " / ", dateVal, "\n")
        return(dateVal)
    }
    void: setValue(me timeValue: setDate) <- {}
    me void: clear() <- <%{
        gtk_entry_set_text((GtkEntry*)yearBox, "");
    }%>
    their GUI_Frame: initialize(me string: label, me timeValue: defaultTime) <- {
        ///// YEAR ///////////////////////////////////
        their GUI_Label: yearLabel <- makeLabelWidget("Year");
        yearBox <- makeEntryBox("")
        ///// MONTH //////////////////////////////////
        their GUI_Label: monthLabel <- makeLabelWidget("Month");
        monthBox <- makeComboBox()
        me int: count <-0
        withEach monthName in months{
            monthBox.appendStringComboBox(toString(count),monthName, monthArrayAdapter)
            count <- count +1
        }
        ///// DAY ////////////////////////////////////
        their GUI_Label: dayLabel <- makeLabelWidget("Day")
        dayBox <- makeComboBox()
        withEach i in RANGE(1..31){
            dayBox.appendComboBox(i, i, dayArrayAdapter)
        }
        ///// RETURN BOX //////////////////////////////
        box <- makeXStack("")
        addToContainer(box, yearLabel)
        addToContainer(box, yearBox)
        addToContainer(box, monthLabel)
        addToContainer(box, monthBox)
        addToContainer(box, dayLabel)
        addToContainer(box, dayBox)
        return(box)
    }
}
struct TimeWidget: COMMAND_addCallProxy=["widgetData:onChanged"]{
    their GUI_ComboBox: hourBox
    their GUI_ComboBox: minuteBox
    me timeValue:       data
    me int[list]:       hours
    me int[list]:       minutes

    their GUI_Frame: initialize(me string: label, me timeValue: defaultTime) <- {
        ///// HOUR //////////////////////////////////
        their GUI_Label: hourLabel <- makeLabelWidget("Hour");
        hourBox <- makeComboBox()
        withEach i in RANGE(1..25){
            hourBox.appendComboBox(i, i, hourArrayAdapter)
        }
        ///// MINUTE //////////////////////////////////
        their GUI_Label: minuteLabel <- makeLabelWidget("Minute");
        minuteBox <- makeComboBox()
        withEach i in RANGE(0..60){
            minuteBox.appendComboBox(i,i, minuteArrayAdapter)
        }
        ///// RETURN BOX //////////////////////////////
        box <- makeXStack("")
        addToContainer(box, hourLabel)
        addToContainer(box, hourBox)
        addToContainer(box, minuteLabel)
        addToContainer(box, minuteBox)
        return(box)
    }
    me timeValue: getValue() <- {
        me int: tmpHour      <- hourBox.comboBoxGetActive()
        tmpHour              <- tmpHour*60*60*1000
        me int: tmpMinute    <- minuteBox.comboBoxGetActive()
        tmpMinute            <- tmpMinute*60*1000
        me timeValue: millisecondsSinceMidnight <- tmpHour + tmpMinute
        return(millisecondsSinceMidnight)
    }
    void: setValue() <- {}
    me void: clear() <- <%{}%>
}
struct scrollerWidget{
    their GUI_Frame: layoutArea
    their GtkWidget: scroller

    their GUI_ScrollingWindow: makeScrollerWidget(their GUI_canvas: canvas) <- <%{
        scroller = gtk_scrolled_window_new(0, 0);
        //GtkWidget* layoutArea = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        //gtk_container_add(GTK_CONTAINER (scroller), layoutArea);
        gtk_container_add(GTK_CONTAINER (scroller), canvas);
        return(scroller);
    }%>
}
/////////////////////////////////  GUI STRUCTS
struct GUI_Entry: wraps = GtkWidget ownerMe = their{
    me string: getValue()               <- <%!gtk_entry_get_text((GtkEntry *)%0)%>
    me string: getValueAsInt()          <- <%!atoi(gtk_entry_get_text((GtkEntry *)%0))%>
}
struct GUI_CompleterBox: wraps = GtkWidget ownerMe = their{
    me string: getValue()               <- <%!gtk_entry_get_text((GtkEntry *)%0)%>
    me string: getValueAsInt()          <- <%!atoi(gtk_entry_get_text((GtkEntry *)%0))%>
}
struct GUI_Completer: wraps = GtkEntryCompletion ownerMe = their{
    me string: getValue()               <- <%!gtk_entry_get_text((GtkEntry *)%0)%>
    me string: getValueAsInt()          <- <%!atoi(gtk_entry_get_text((GtkEntry *)%0))%>
}
struct GUI_ComboBox: wraps = GtkWidget ownerMe = their{
    me void: appendComboBox(me string: id, me string: label)  <- <%!gtk_combo_box_text_append((GtkComboBoxText*)%0,(gchar*)std::to_string(%1).data(),(gchar*)std::to_string(%2).data())%>
    me void: appendStringComboBox(me string: id, me string: label)  <- <%!gtk_combo_box_text_append((GtkComboBoxText*)%0,(gchar*)%1.data(),(gchar*)%2.data())%>
    me int: comboBoxGetActive()  <- <%!gtk_combo_box_get_active((GtkComboBox *)%0)%>
    me void: setAndroidAdapter() <- <%!%G %>
    me string: getValue()        <- <%!gtk_combo_box_get_active((GtkComboBox*)%0)%>
}
struct GUI_SpinBox: wraps = GtkWidget ownerMe = their{
    me double: getValue()               <- <%!gtk_spin_button_get_value((GtkSpinButton *)%0)%>
}
struct GUI_Bool: wraps = GtkWidget ownerMe = their{
    me string: getValue()               <- <%!gtk_toggle_button_get_active((GtkToggleButton*)%0)%>
    me void: setValue(me int: value)    <- <%!gtk_toggle_button_set_active ((GtkToggleButton*)%0, %1)%>
}
struct GUI_Label: wraps = GtkWidget ownerMe = their{
    void: setValue(me string: text)     <- <%!gtk_label_set_text (GTK_LABEL(%0), %1.data())%>
}
struct GUI_TextViewer: wraps = GtkWidget ownerMe = their{
    me void: setEditable(me bool: isEditable)                 <- <%!gtk_text_view_set_editable(GTK_TEXT_VIEW(%0), %1)%>
}
struct GUI_button: wraps = GtkButton ownerMe = their{
    me void: setWidgetActive            <- <%!gtk_widget_set_sensitive ((GtkWidget* )%0, %1)%>
}
/////////////////////////////////  LIST EDITOR WIDGET
struct ListWidgetManager{
    their GUI_Frame:         box
    their GUI_Frame:         boxHeader
    their GUI_Frame:         boxBody
    their GUI_Frame:         boxFooter
    their listWidget:        listWidgetView
    their GtkWidget:         addBtn
    their GtkWidget:         deleteBtn
    their GtkWidget:         editBtn
    me int:                  crntIndex <- 0
    me int:                  listLength
    their GtkListBoxRow:     crntRow

    void: handleOnListClick(me int: idx) <- <%{
        cout << "List Clicked at index: "<< to_string(idx)<<"\n";
        crntIndex = idx;
        setCurrentItem(crntIndex);
    }%>
    void: handleAdd() <- <%{
        allocateNewCurrentItem();
        GtkWidget* itemWidget = makeEditableWidget();
        GtkDialogFlags flags = (GtkDialogFlags)(GTK_DIALOG_MODAL);
        GtkWidget* AddItemDialog = gtk_dialog_new_with_buttons ("Add", (GtkWindow*)window, flags, "_OK", 1, "_Cancel", 0, NULL);
        GtkWidget* contentArea = gtk_dialog_get_content_area((GtkDialog*)AddItemDialog);
        gtk_container_add (GTK_CONTAINER (contentArea), itemWidget);
        gtk_widget_show_all(AddItemDialog);
        int result = gtk_dialog_run ((GtkDialog*)AddItemDialog);
        if(result==1){
            updateCrntFromEdited(crntIndex);
            listLength = pushCrntToList(crntIndex);
            setButtonsActive(listLength);
        } else {cout<<"CANCELED "<<result<<"\n";}
        gtk_widget_destroy(AddItemDialog);
    }%>
    void: handleDelete() <- <%{
        crntRow = gtk_list_box_get_selected_row((GtkListBox*)listWidgetView);
        crntIndex = gtk_list_box_row_get_index(crntRow);
        cout << "Delete Btn Clicked at idx: "<< crntIndex <<"\n";
        if (crntIndex >= 0) {
            GtkDialogFlags flags = (GtkDialogFlags)(GTK_DIALOG_MODAL);
            GtkWidget* DeleteItemDialog = gtk_dialog_new_with_buttons ("Delete Item", (GtkWindow*)window, flags, "_OK", 1, "_Cancel", 0, NULL);
            GtkWidget* contentArea = gtk_dialog_get_content_area((GtkDialog*)DeleteItemDialog);
            gtk_widget_show_all(DeleteItemDialog);
            int result = gtk_dialog_run ((GtkDialog*)DeleteItemDialog);
            if(result==1){
                cout<<"ACCEPTED "<<result<<"\n";
                listLength = deleteNthItem(crntIndex);
                setButtonsActive(listLength);
                gtk_container_remove((GtkContainer*)boxBody, listWidgetView);
                listWidgetView = makeListViewWidget();
                gtk_box_pack_start(GTK_BOX(boxBody), listWidgetView, true, true, 0);
                gtk_widget_show_all(listWidgetView);
            } else {cout<<"CANCELED "<<result<<"\n";}
            gtk_widget_destroy(DeleteItemDialog);
        }
    }%>
    void: handleEdit() <- <%{
        crntIndex = gtk_list_box_row_get_index(gtk_list_box_get_selected_row((GtkListBox*)listWidgetView));
        cout << "Edit Btn Clicked at idx: "<< crntIndex <<"\n";
        if (crntIndex >= 0) {
            allocateNewCurrentItem();
            GtkWidget* itemWidget = makeEditableWidget();
            updateEditableWidget(crntIndex);
            GtkDialogFlags flags = (GtkDialogFlags)(GTK_DIALOG_MODAL);
            GtkWidget* AddItemDialog = gtk_dialog_new_with_buttons ("Edit", (GtkWindow*)window, flags, "_OK", 1, "_Cancel", 0, NULL);
            GtkWidget* contentArea = gtk_dialog_get_content_area((GtkDialog*)AddItemDialog);
            gtk_container_add (GTK_CONTAINER (contentArea), itemWidget);
            gtk_widget_show_all(AddItemDialog);
            int result = gtk_dialog_run ((GtkDialog*)AddItemDialog);
            if(result==1){
                cout<<"ACCEPTED "<<result<<"\n";
                updateCrntFromEdited(crntIndex);
                copyCrntBackToList(crntIndex);
                gtk_container_remove((GtkContainer*)boxBody, listWidgetView);
                listWidgetView = makeListViewWidget();
                gtk_box_pack_start(GTK_BOX(boxBody), listWidgetView, true, true, 0);
                gtk_widget_show_all(listWidgetView);
            } else {cout<<"CANCELED "<<result<<"\n";}
            gtk_widget_destroy(AddItemDialog);
        }
    }%>
    void: setButtonsActive(me int: L) <- <%{
        if(L>0){
            gtk_widget_set_sensitive (deleteBtn, TRUE);
            gtk_widget_set_sensitive (editBtn, TRUE);
        }else{
            gtk_widget_set_sensitive (deleteBtn, FALSE);
            gtk_widget_set_sensitive (editBtn, FALSE);
        }
    }%>
    their GUI_Frame: makeListBox() <- <% {
        // BOX
        box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
        // HEADER
        boxHeader = makeListHeader();
        gtk_box_pack_start(GTK_BOX(box), boxHeader, false, true, 0);
        // BODY
        boxBody = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
        listWidgetView = makeListViewWidget();
        gtk_box_pack_start(GTK_BOX(box), boxBody, true, true, 0);
        gtk_box_pack_start(GTK_BOX(boxBody), listWidgetView, true, true, 0);
        // FOOTER
        boxFooter = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        addBtn = gtk_button_new_with_label("Add");
        deleteBtn = gtk_button_new_with_label("Remove");
        editBtn = gtk_button_new_with_label("Edit");
        listLength <- getListLength();
        setButtonsActive(listLength);
        gtk_box_pack_start(GTK_BOX(boxFooter), addBtn, true, true, 10);
        gtk_box_pack_start(GTK_BOX(boxFooter), deleteBtn, true, true, 10);
        gtk_box_pack_start(GTK_BOX(boxFooter), editBtn, true, true, 10);
        gtk_box_pack_start(GTK_BOX(box), boxFooter, false, true, 0);
        // CALLBACKS
        g_signal_connect(G_OBJECT(listWidgetView), "row-selected", G_CALLBACK(ListEditorHandleListClick), this);
        g_signal_connect(G_OBJECT(addBtn), "clicked", G_CALLBACK(ListEditorHandleAdd), this);
        g_signal_connect(G_OBJECT(deleteBtn), "clicked", G_CALLBACK(ListEditorHandleDelete), this);
        g_signal_connect(G_OBJECT(editBtn), "clicked", G_CALLBACK(ListEditorHandleEdit), this);
        return box;
    } %>
}

struct GUI_CompleterList: wraps = GtkListStore ownerMe = their{}

/////////////////////////////////  GLOBAL WIDGET CODE CONVERTERS
struct GLOBAL{
    me void: setBtnProxy()  <- <%!%Gg_signal_connect(G_OBJECT(%1), %2, G_CALLBACK(%3_%4_CB), %5)%>
    me void: setItmSelectedProxy()  <- <%!%Gg_signal_connect(G_OBJECT(%1), %2, G_CALLBACK(%3_%4_CB), %5)%>
    their GtkWidget: makeBoolWidget(me string: label)           <- <%!%Ggtk_entry_new()%>
    their GtkWidget: makeFloatWidget(me string: label)          <- <%!%Ggtk_entry_new()%>
    their GtkWidget: makeSpinBox(me double: initialValue, me double: minValue, me double: maxValue, me int: decimalPlaces) <- <%!%Ggtk_spin_button_new(gtk_adjustment_new(%1,%2,%3,1,10,10),1,%4)%>
    their GtkWidget: makeNumRangeWidget(me string: label)       <- <%!%Ggtk_entry_new()%>
    their GtkWidget: makeRangeWidget(me string: label)          <- <%!%Ggtk_entry_new()%>
    their GtkWidget: makeTimeWidget(me string: label)           <- <%!%Ggtk_entry_new()%>
    their GtkWidget: makeDateWidget(me string: label)           <- <%!%Ggtk_entry_new()%>
    their GtkWidget: makeTimeWidget()                           <- <%!%Ggtk_combo_box_text_new()%>
    their GtkWidget: makeDateWidget()                           <- <%!%Ggtk_combo_box_text_new()%>
    their GtkButton: makeButtonWidget(me string: label)         <- <%!%G(GtkButton*)gtk_button_new_with_label(%1)%>
    their GtkWidget: makeListWidget(me string: label)           <- <%!%Ggtk_list_box_new()%>
    their GtkWidget: makeRowWidget(me string: label)            <- <%!%Ggtk_list_box_row_new()%>
    their GtkWidget: makeYStack(me string: label)               <- <%!%Ggtk_box_new(GTK_ORIENTATION_VERTICAL, 0)%>
    their GtkWidget: makeXStack(me string: label)               <- <%!%Ggtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)%>
    their GtkWidget: makeZStack(me string: label)               <- <%!%Ggtk_stack_new()%>
    their GtkWidget: makeTabbedWidget(me string: label)         <- <%!%Ggtk_notebook_new()%>
    their GtkWidget: makeLabelWidget(me string: label)          <- <%!%Ggtk_label_new(%1)%>
    their GtkWidget: makeLabelWidget2(me string: label)         <- <%!%Ggtk_label_new(%1.data())%>
    their GtkWidget: makeComboBox(me string: label)             <- <%!%Ggtk_combo_box_text_new()%>
    me void: addToComboBox(me GUI_item: box, me string: val)    <- <%!%Ggtk_combo_box_text_append_text((GtkComboBoxText *)%1, %2.data())%>
    their GtkWidget: makeEntryBox(me string: label)             <- <%!%Ggtk_entry_new()%>
    void: setEntryCompleter(their GUI_Entry: box, their GUI_Completer: completer)
        <- <%!%Ggtk_entry_set_completion((GtkEntry*)%1, %2)%>
    their GtkEntryCompletion: makeCompleter(me string: label, their GUI_CompleterList: list_store, me string[list]: items) <- <%{
        GtkEntryCompletion* completion = gtk_entry_completion_new();
        list_store = gtk_list_store_new(1, G_TYPE_STRING);
        GtkTreeIter iter;
        gint column = 0;
        gtk_entry_completion_set_model(completion, (GtkTreeModel*)list_store);
        gtk_entry_completion_set_text_column(completion, column);
        for( uint64_t itemIdx = 0; itemIdx < items.size(); ++itemIdx ){
            string item = items[itemIdx];
        gtk_list_store_append(list_store, &iter);
            gtk_list_store_set(list_store, &iter, column, item.data(), -1);
        }
        return(completion);
    }%>
    their GUI_CompleterBox: makeCompleterBox(me string: label)
        <- <%!%Ggtk_entry_new()%>
    me void: setLabelWidth(their GtkWidget: labelWidget, me int: width) <- <%!gtk_label_set_width_chars((GtkLabel*)%1, %2)%>
    me void: setListWidgetSelectionMode(their listWidget: listWidgetView, me string: mode) <- <%!gtk_list_box_set_selection_mode((GtkListBox *)%1, GTK_SELECTION_SINGLE)%>
    me int: getListRowIndex() <- <%!%Ggtk_list_box_row_get_index((GtkListBoxRow *)%1)%>
    their GtkWidget: getListRowSelected(their listWidget: listWidgetView) <- <%!%G(GtkWidget*)gtk_list_box_get_selected_row((GtkListBox *)%1)%>
    me void: setTabLabelText() <- <%!%Ggtk_notebook_set_tab_label_text(GTK_NOTEBOOK(%1), %2, %3)%>
    me GUI_Scalar: convertToGUIScalar()                                    <- <%!%G%1%>
    their GUI_Bool: makeCheckBox()                                         <- <%!%Ggtk_check_button_new()%>
    their GUI_VerticalScroller: makeVerticalScroller()                     <- <%!%GmakeGTKVerticalScroller()%>
    their GUI_TextViewer: makeTextViewer(me string: text)                  <- <%!%GmakeGTKTextViewer(%1)%>
    me void: setButtonLabel(their GtkButton: btn, me string: label)
        <- <%!%Ggtk_button_set_label(%1,%2)%>

    their GUI_TextViewer: makeGTKTextViewer(me string: text)    <- <%{
        GtkWidget *textViewer = gtk_text_view_new();
        GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW (textViewer));
        int length = strlen(text.data());
        gtk_text_buffer_set_text (buffer,text.data(),length);
        gtk_text_view_set_editable(GTK_TEXT_VIEW(textViewer), FALSE);
        gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(textViewer), FALSE);
        gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(textViewer),GTK_WRAP_WORD);
        return textViewer;
    }%>
    their GUI_VerticalScroller: makeGTKVerticalScroller() <- <%{
        GtkWidget* scroller = gtk_scrolled_window_new(NULL, NULL);
        //gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(scroller),height);
        //gtk_scrolled_window_set_max_content_width(GTK_SCROLLED_WINDOW(scroller),width);
        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroller), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
        return(scroller);
    }%>
    their GtkWidget: makeListEditorWidget(their GtkWidget: listWidgetView) <- <%{
        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
        gtk_box_pack_start(GTK_BOX(box), listWidgetView, true, true, 0);

        GtkWidget* btnBox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
        GtkWidget* addBtn = gtk_button_new_with_label("Add");
        GtkWidget* delBtn = gtk_button_new_with_label("Remove");
        GtkWidget* editBtn = gtk_button_new_with_label("Edit");

        gtk_box_pack_start(GTK_BOX(btnBox), addBtn, true, true, 10);
        gtk_box_pack_start(GTK_BOX(btnBox), delBtn, true, true, 10);
        gtk_box_pack_start(GTK_BOX(btnBox), editBtn, true, true, 10);
        gtk_box_pack_start(GTK_BOX(box), btnBox, false, true, 0);
        return box;
    }%>
}
/////////////////////////////////  GLOBAL WIDGET FUNCTIONS
struct GLOBAL{
    me void: addToContainerAndShowWidget (their GUI_container: parentContainer, their GUI_item: childWidget) <- <%{
        gtk_container_add(parentContainer, childWidget);
        gtk_widget_show(childWidget);
    }%>
}
///////////////////////////////// GLOBAL CALLBACKS
struct GLOBAL{
    void: ListEditorHandleListClick(their GtkListBox: box, their GtkListBoxRow: row, their void: user_data) <- <% {
        ListWidgetManager *listMgr =(ListWidgetManager *)user_data;
        int idx = gtk_list_box_row_get_index(gtk_list_box_get_selected_row(box));
        listMgr->handleOnListClick(idx);
    } %>
    void: ListEditorHandleAdd(their GtkWidget: wid, their ListWidgetManager: listMgr) <- {
        listMgr.handleAdd()
    }
    void: ListEditorHandleDelete(their GtkWidget: wid, their ListWidgetManager: listMgr) <- {
        listMgr.handleDelete()
    }
    void: ListEditorHandleEdit(their GtkWidget: wid, their ListWidgetManager: listMgr) <- {
        listMgr.handleEdit()
    }
}
/////////////////////////////////  HANDLE EVENTS
struct GUI_MotionEvent: wraps = GdkEventMotion ownerMe = their{
  me uint: type
 // GdkWindow *window;
 // gint8 send_event;
 // guint32 time;
  me double: x
  me double: y

  me uint: state
  me uint: button
}
struct GUI_ButtonEvent: wraps = GdkEventButton ownerMe = their{
  me uint: type
 // GdkWindow *window;
 // gint8 send_event;
 // guint32 time;
  me double: x
  me double: y
  me uint: state
  me uint: button
}
struct GUI_PointerEvent: wraps = GdkEventButton ownerMe = their{
  me uint: type
 // GdkWindow *window;
 // gint8 send_event;
 // guint32 time;
  me double: x
  me double: y

  me uint: state
  me uint: button
}
struct GUI_KeyboardEvent{
    their GdkEventKey: GUI_KeyboardEvent
    me uint: type
    me uint: state
    me uint: keyval
}
/////////////////////////////////  EVENT DISPATCHER
struct GUI_eventDispatcher{
    their widget: topWidget

    me bool: dispatchPointerMotionEvent(their GdkEventMotion: event) <- <%{
        event->x = event->x / scaleFactor;
        event->y = event->y / scaleFactor;
        topWidget->mouseMoved(event);
        return false;
    } %>
    me bool: dispatchPointerClickEvent(their GdkEventButton: event) <- <%{
        event->x = event->x / scaleFactor;
        event->y = event->y / scaleFactor;
        if(event->type==GDK_BUTTON_PRESS){
            if(event->button==1){
                topWidget->primaryDn(event);
            } else if(event->button==3){
                topWidget->secondaryClick(event);
            }
        } else if(event->type==GDK_BUTTON_RELEASE){
            if(event->button==1){
                topWidget->primaryUp(event);
                topWidget->primaryClick(event);
            } else if(event->button==3){
                topWidget->secondaryUp(event);
            }
        }
        return false;
    } %>
    me bool: dispatchKeyboardEvent(their GdkEventKey: event) <- <%{
        topWidget->keyTyped(event);
        return(true);
    }%>
  //  me bool: dispatchWindowEvent(their GdkEventConfigure: event) <- {print("Config\n")}
    // Also: timer, data and user events

    me void: registerWidgetForEventDispatcher(their GUI_item: Widget, their widget: masterWidget) <- <%{
        topWidget = masterWidget;

        g_signal_connect(Widget, "draw", G_CALLBACK(drawAppArea_cb), topWidget);
//      g_signal_connect (Widget, "expose_event",      G_CALLBACK(expose_event), topWidget);
//      g_signal_connect (Widget, "configure_event",   G_CALLBACK(configure_event), topWidget);
        g_signal_connect (Widget, "motion_notify_event", G_CALLBACK(motion_notify_event), topWidget);
        g_signal_connect (Widget, "button_press_event",  G_CALLBACK(button_press_event), topWidget);
        g_signal_connect (Widget, "button_release_event",  G_CALLBACK(button_release_event), topWidget);
        g_signal_connect (window, "key_press_event",  G_CALLBACK(keypress_event), topWidget);

        gtk_widget_set_events (Widget, GDK_EXPOSURE_MASK
             | GDK_LEAVE_NOTIFY_MASK
             | GDK_BUTTON_PRESS_MASK
             | GDK_BUTTON_RELEASE_MASK
             | GDK_POINTER_MOTION_MASK
             | GDK_POINTER_MOTION_HINT_MASK
             | GDK_KEY_PRESS_MASK
             | GDK_KEY_RELEASE_MASK
        );
    } %>
}

/////////////////////////////////  GLOBAL EVENT HANDLERS
struct GLOBAL{
    me void: button_press_event(their GtkWidget: wid, their GdkEventButton: event, their void: data) <- <%{
        ((DashboardWidget*) data)->EventDispatcher.dispatchPointerClickEvent(event);
    } %>
    me void: button_release_event(their GtkWidget: wid, their GdkEventButton: event, their void: data) <- <%{
        ((DashboardWidget*) data)->EventDispatcher.dispatchPointerClickEvent(event);
    } %>
    me void: motion_notify_event(their GtkWidget: wid, their GdkEventMotion: event, their void: data) <- <%{
        ((DashboardWidget*) data)->EventDispatcher.dispatchPointerMotionEvent(event);
    } %>
    me void: expose_event(their GtkWidget: wid, their GdkEventExpose: event, their void: data) <- <%{
      //  ((DashboardWidget*) data)->EventDispatcher.dispatchWindowEvent(event);
    } %>
    me void: keypress_event(their GtkWidget: wid, their GdkEventKey: event, their void: data) <- <%{
        ((DashboardWidget*) data)->EventDispatcher.dispatchKeyboardEvent(event);
    } %>
    me void: configure_event(their GtkWidget: wid, their GdkEventConfigure: event, their void: data) <- <%{
      //  EventDispatcher.dispatchWindowEvent(event);
    } %>
    me bool: drawAppArea_cb(their GtkWidget: gtk_top_widget, their GUI_ctxt: cr, their void: data) <- <%{
        widget* DBW = (widget*)data;
        cairo_scale(cr, scaleFactor, scaleFactor);
        DBW->draw(cr);
        return(true);
    }%>
    void: clickBack_CB(their GtkWidget: btn, their appComponentGUI: wid) <- <%{
        appComponentGUI* clickWidget = (appComponentGUI*)wid;
        clickWidget->clickBack();
    }%>
    void: clickNext_CB(their GtkWidget: btn, their appComponentGUI: wid) <- <%{
    appComponentGUI* clickWidget = (appComponentGUI*)wid;
        clickWidget->clickNext();
    }%>
}
/////////////////////////////////  HANDLE GUI
struct GUI_canvas: wraps = GtkWidget ownerMe = their{
    me void: setParent(our DashboardWidget: wid) <- <%!%G%>
}
/////////////////////////////////  HANDLE GUI
struct GUI{
    their GtkApplication: app

    me uint32: GUI_Init() <- {
        app <- gtk_application_new (0, G_APPLICATION_FLAGS_NONE)
        g_signal_connect (app, "activate", G_CALLBACK(activate), NULL)
        return(0)
    }
    me uint32: GUI_Run() <- <% {
        uint32_t status;
        status = g_application_run( G_APPLICATION(app), 0, 0);
        return(status);
    } %>
    me void: GUI_Deinit() <- {
        g_object_unref(app)
    }
}

struct GUI{
    their GUI_item: newCanvas() <- <%!%Ggtk_drawing_area_new()%>
    me void: setWidgetSize(their GUI_item: widget, me uint32: width, me uint32: height) <- <%!%Ggtk_widget_set_size_request(%1, %2, %3)%>
    me void: addMenuBar(me GUI_menuBar: menubar) <- <%!%G %>
    me void: create_MenuItem(me GUI_menu: ParentMenu, me string: label)<- <%!%Gcreate_MenuItem(%1, %2)%>
    me void: create_TopSubMenu(me GUI_menuBar: ParentMenu, me string: label)<- <%!%Gcreate_SubMenu(%1, %2)%>
    me void: create_SubMenu(me GUI_menu: ParentMenu, me string: label)<- <%!%Gcreate_SubMenu(%1, %2)%>
    me void: setCallback()     <- <%!%Gg_signal_connect(G_OBJECT(%1), %2, G_CALLBACK(%3), %4)%>
    me void: setBtnCallback()  <- <%!%Gg_signal_connect(G_OBJECT(%1), %2, G_CALLBACK(%3_CB), %4)%>
    me void: setBtnCallback2() <- <%!%Gg_signal_connect(G_OBJECT(%1), %2, G_CALLBACK(%3), %4.get())%>
    me void: setBtnCallback3()  <- <%!%Gg_signal_connect(G_OBJECT(%1), %2, G_CALLBACK(%3_%4_CB), %5)%>
}

struct GUI_ctxt: wraps = cairo_t ownerMe = their{
    me void: fetchAreaToBeDrawn(me GUI_rect: area) <- <%!cairo_clip_extents(%0, &%1.x1, &%1.y1, &%1.x2, &%1.y2)%>
    me void: reset() <- <%!%G %>
    me void: setRGBA(me double: red, me double: green, me double: blue, me double: alpha) <- <%!cairo_set_source_rgba(%0, (double)%1 /256, (double)%2 /256, (double)%3 /256, (double)%4 /256)%>
    me void: setRGB (me double: red, me double: green, me double: blue) <- <%!cairo_set_source_rgb(%0, (double)%1 /256, (double)%2 /256, (double)%3 /256)%>
    me void: setColor(me cdColor: color) <- <%!cairo_set_source_rgb(%0, (double)%1.red /256, (double)%1.green /256, (double)%1.blue /256)%>
    me void: setLineWidth(me double: width) <- <%!cairo_set_line_width(%0, %1)%>
    me void: finishPDF() <- <%!cairo_surface_finish(cairo_get_group_target(%0))%>
    me void: setScale() <- <%!cairo_scale(%0, %1, %2)%>
    me void: setOffset() <- <%!cairo_translate(%0, %1, %2)%>
    me void: moveTo(me double: x, me double: y) <- <%!cairo_move_to(%0, %1, %2)%>
    me void: lineTo(me double: x, me double: y) <- <%!cairo_line_to(%0, %1, %2)%>
    me void: moveRel(me double: dx, me double: dy) <- <%!cairo_rel_move_to(%0, %1, %2)%>
    me void: lineRel(me double: dx, me double: dy) <- <%!cairo_rel_line_to(%0, %1, %2)%>
    me void: curveTo(me double: x1, me double: y1, me double: x2, me double: y2, me double: x3, me double: y3) <- <%!cairo_curve_to(%0, %1, %2, %3, %4, %5, %6)%>
    me void: curveRel(me double: dx1, me double: dy1, me double: dx2, me double: dy2, me double: dx3, me double: dy3) <- <%!cairo_rel_curve_to(%0, %1, %2, %3, %4, %5, %6)%>
    me void: closePath() <- <%!cairo_close_path(%0)%>
    me void: rectangle() <- <%!cairo_rectangle(%0, %1, %2, %3, %4)%>
    me void: paintNow() <- <%!cairo_paint(%0)%>
    me void: strokeNow() <- <%!cairo_stroke(%0)%>
    me void: fillNow() <- <%!cairo_fill(%0)%>
    me void: strokeKeep() <- <%!cairo_stroke_preserve(%0)%>
    me void: fillKeep() <- <%!cairo_fill_preserve(%0)%>
    me void: setFillPattern() <- <%!cairo_set_source(%0, %1)%>
    me void: circle(me int: centerX, me int: centerY, me int: radius) <- <%!cairo_arc(%0, %1, %2, %3, 0, 2 * M_PI)%>
    their GUI_ctxt: newPDF_ctxt(me sting: filename, me double: inchesWide, me double: inchesHigh) <- <%!%Gcairo_create(cairo_pdf_surface_create(%1.data(), %2*70, %3*70))%>
}

struct guiFillPattern{
    their cairo_pattern_t: guiFillPattern
    me void: init() <- <%!%0 = cairo_pattern_create_linear(%1, %2, %3, %4)%>
    me void: AddColorStopRGBA(me double: offset, their cdColor: color, me int: alpha) <- <%!cairo_pattern_add_color_stop_rgba(%0, %1, (double)%2.red/265, (double)%2.green/256, (double)%2.blue/256, (double)%3/256)%>
    me void: AddColorStop(me double: offset, cdColor: color) <- <%!cairo_pattern_add_color_stop_rgb(%0, %1, (double)%2.red/265, (double)%2.green/256, (double)%2.blue/256)%>
    me void: destroy() <- <%!cairo_pattern_destroy(%0)%>
}

///////////////////////////////// TIME
struct tm{
    me tm: tm
    me int: tm_hour
    me int: tm_min
    me int: tm_sec
}

struct timeStringer{
    me tm: timeRec
    me none: timeStringer() <- <%{
        time_t rawtime;
        time (&rawtime);
        timeRec = *localtime(&rawtime);
    } %>

    me string: time12Hour() <- <%{
        string AmPm = "am";
        int hours = timeRec.tm_hour;
        if (hours>=12) {hours = hours-12; AmPm="pm";}
        if (hours==0) {hours = 12;}
        string SH = (to_string(hours)+":");
        int min = timeRec.tm_min;
        if (min<10){SH = SH+"0";}
        SH = SH + to_string(min);

        SH=SH+":";
        int sec = timeRec.tm_sec;
        if (sec<10){SH = SH+"0";}
        SH = SH + to_string(sec);
        SH=SH+AmPm;
        return(SH);
    } %>
}

/////////////////////////////////  G L O B A L
struct GLOBAL{
    me APP: thisApp
    me float: displayDensity
    me double: scaleFactor <- 1.0

    // //TIME ROUTINES:
    me int64: ticksPerSec() <- <%!%GG_USEC_PER_SEC%>
    me int64: getCurrentTimeStamp() <- <%!g_get_real_time()/1000%>

    // //DRAWING ROUTINES:
    me deltaSize: renderText(their GUI_ctxt: cr, me string: text, me fontSpec: font, me double: x, me double: y) <- <%{
        cairo_move_to(cr,x,y);
        PangoLayout *layout=pango_cairo_create_layout(cr);
        pango_layout_set_text(layout, text.data(), -1);

        string fontDesc=font.name+' '+ std::to_string(font.size);
        PangoFontDescription *desc = pango_font_description_from_string(fontDesc.data());
        pango_layout_set_font_description(layout, desc);
        pango_font_description_free(desc);

        cairo_set_line_width(cr, 0.5);
        pango_cairo_update_layout(cr, layout);
        pango_cairo_show_layout_line (cr, pango_layout_get_line (layout, 0));
       // pango_cairo_layout_path(cr, layout);
        deltaSize size;
        pango_layout_get_pixel_size(layout, &size.width, &size.height);
        g_object_unref(layout);
        cairo_fill(cr);
        return(size);
    }%>

    me deltaSize: renderTextCentered(their GUI_ctxt: cr, me string: text, me fontSpec: font, me double: x, me double: y) <- <%{
        deltaSize size = getTextSize(cr, text, font);
        renderText(cr, text, font, x-size.width/2, y);
        return(size);
    }%>

    me deltaSize: renderTextRotate(their GUI_ctxt: cr, me string: text, me fontSpec: font, me double: x, me double: y, me double: degrees, me string: justify) <- <%{
        double radians    = degrees*(M_PI/180.);
        deltaSize size    = getTextSize(cr, text, font);
        double hypotenuse = size.width;
        deltaSize tmpSize;

        rotate(cr, x, y, -45);
        if(justify == "right"){x=x-hypotenuse;}
        else if(justify == "center"){x=x-hypotenuse/2;}
        renderText (cr, text, font, x, y);
        cairo_restore(cr);
        //TODO: calculate height and width more accurately
        tmpSize.height       = cos(abs(radians))*hypotenuse;
        tmpSize.width        = sin(abs(radians))*hypotenuse;
        hypotenuse           = size.height;
        radians              = M_PI/2 - abs(radians);
        tmpSize.height       = tmpSize.height + sin(radians)*hypotenuse;
        tmpSize.width        = tmpSize.width + cos(radians)*hypotenuse;
        //size.width = size.width*0.9;
        //size.height = size.width;
        return(tmpSize);
    }%>

    me void: rotate(their GUI_ctxt: cr, me double: x, me double: y, me int: degrees) <- <%{
    double radians = degrees*(M_PI/180.);
    cairo_save(cr);
    cairo_translate(cr,x,y);
    cairo_rotate(cr, radians);
    cairo_translate(cr,-x,-y);
    }%>

    me void: restore() <- <%!cairo_restore(cr)%>

    me deltaSize: getTextSize(their GUI_ctxt: cr, me string: text, me fontSpec: font) <- <%{
        PangoLayout *layout=pango_cairo_create_layout(cr);
        pango_layout_set_text(layout, text.data(), -1);

        string fontDesc=font.name+' '+ std::to_string(font.size);
        PangoFontDescription *desc = pango_font_description_from_string(fontDesc.data());
        pango_layout_set_font_description(layout, desc);
        pango_font_description_free(desc);

        deltaSize size;
        pango_layout_get_pixel_size(layout, &size.width, &size.height);
        g_object_unref(layout);
        return(size);
    } %>

    me void: roundedRectangle(their GUI_ctxt: cr, me double: x, me double: y, me double: w, me double: h, me double: r) <- <%{
        cairo_move_to(cr,x+r,y);                      //# Move to A
        cairo_line_to(cr,x+w-r,y);                    //# Straight line to B
        cairo_curve_to(cr,x+w,y,x+w,y,x+w,y+r);       //# Curve to C, Control points are both at Q
        cairo_line_to(cr,x+w,y+h-r);                  //# Move to D
        cairo_curve_to(cr,x+w,y+h,x+w,y+h,x+w-r,y+h); //# Curve to E
        cairo_line_to(cr,x+r,y+h);                    //# Line to F
        cairo_curve_to(cr,x,y+h,x,y+h,x,y+h-r);       //# Curve to G
        cairo_line_to(cr,x,y+r);                      //# Line to H
        cairo_curve_to(cr,x,y,x,y,x+r,y);             //# Curve to A;
    } %>

    me map<me string, me INK_Image>: InkImgCache
    me void: displayImage(their GUI_ctxt: cr, me string: filename, me double: x, me double: y, me double: scale) <- <%{
        filename = "./assets/" + filename;
        map< string, cairo_surface_t* >::iterator picPtr=InkImgCache.find(filename);
        cairo_surface_t* pic=0;
        if (picPtr==InkImgCache.end()) {
            pic=cairo_image_surface_create_from_png(filename.data());
            InkImgCache[filename]=pic;
            }
        else pic=picPtr->second;

        cairo_save(cr);
        cairo_scale(cr,1/scale,1/scale);
        cairo_set_source_surface(cr,pic,x*scale,y*scale);
        cairo_paint(cr);
        cairo_restore(cr);
   }%>
    // //GUI INTERFACE:
    /* Surface to store current scribbles */
    their cairo_surface_t: surface <- 0

me void: close_window() <- <%{
  if (surface){
    cairo_surface_destroy(surface);
  }
  g_application_quit((GApplication*)thisApp.gui->app);
}%>

    // //MENU ROUTINES:
me GUI_menuItem: create_MenuItem(me GUI_menu: ParentMenu, me string: label) <- <%{
    GtkWidget *menuitem;

    menuitem = gtk_menu_item_new_with_label (label.data());
    //gtk_menu_item_set_submenu (GTK_MENU_ITEM (menuitem), SubMenu);
    gtk_menu_shell_append (GTK_MENU_SHELL (ParentMenu), menuitem);
    gtk_widget_show (menuitem);

  return menuitem;
} %>

me GUI_menu: create_SubMenu(me GUI_menu: ParentMenu, me string: label) <- <%{
    GtkWidget *SubMenu = gtk_menu_new ();
    GtkWidget *menuitem;

    menuitem = gtk_menu_item_new_with_label (label.data());
    gtk_menu_item_set_submenu (GTK_MENU_ITEM (menuitem), SubMenu);
    gtk_menu_shell_append (GTK_MENU_SHELL (ParentMenu), menuitem);
    gtk_widget_show (menuitem);

  return SubMenu;
} %>
me void: getMetrics() <- <%{
    displayDensity   = 1;
}%>
me void: showWidget(me GUI_item: widget) <-  <%!gtk_widget_show(GTK_WIDGET(%1))%>
me void: hideWidget(their GUI_item: widget) <- <%!gtk_widget_hide(GTK_WIDGET(%1))%>
me void: markDirtyArea(me GUI_item: widget, me int32: x, me int32: y, me int32: width, me int32: height) <- <%!gtk_widget_queue_draw_area(%1, %2, %3, %4, %5)%>
//me GUI_item: newCanvas() <- <%!gtk_drawing_area_new()%>
me void: setWidgetSize(me GUI_item: widget, me uint32: width, me uint32: height) <- <%!gtk_widget_set_size_request(%1, %2, %3)%>
me int: widgetHeight() <- <%!gtk_widget_get_allocated_height(%1)%>
me int: widgetWidth() <- <%!gtk_widget_get_allocated_width(%1)%>
me void: addToContainer(me GUI_container: container, me GUI_item: widget) <- <%!addToContainerAndShowWidget(GTK_CONTAINER (%1), (GtkWidget*)%2)%>
me void: addToContainerAndExpand(me GUI_container: container, their GUI_item: widget) <-<%!%Ggtk_box_pack_start(GTK_BOX(%1), %2, TRUE, TRUE, 0)%>
me void: addToZStack(me GUI_container: container, their GUI_item: widget) <-<%!%Ggtk_stack_add_named(GTK_STACK(%1), %2, %3)%>
me void: setZStackActive(their GUI_item: widget, me string: S) <- <%!%Ggtk_stack_set_visible_child_name(GTK_STACK(%1), %2.data())%>
their GUI_item: newScrollingWindow() <- <%!%Ggtk_scrolled_window_new(NULL, NULL)%>
}

/////////////////////////////////  INTER-THREAD COMMUNICATION

// Initialization: get main thread's "mainContext" and store it and make a global getter for it.
struct MessagePasser {their GMainContext: MessagePasser}

struct workerMsgThread: inherits = Threads {
    their MessagePasser: mesgPasser
    void: run() <- <%{
        mesgPasser = g_main_context_new();
        workerThreadMessagePasser = mesgPasser;
        GMainLoop *main_loop;

        /* Set up the threadâ€™s context and run it forever. */
        g_main_context_push_thread_default (mesgPasser);

        main_loop = g_main_loop_new (mesgPasser, FALSE);
        g_main_loop_run (main_loop);
        g_main_loop_unref (main_loop);

        g_main_context_pop_thread_default (mesgPasser);
        g_main_context_unref (mesgPasser);

    }%>
}

struct GLOBAL{
    their MessagePasser: GUI_threads_messagePasser <- NULL   // Set this at beginning of the program
    their MessagePasser: workerThreadMessagePasser <- NULL   // Set this at beginning of the program
    their MessagePasser: threadsMesgPasser() <- <%!g_main_context_get_thread_default()%>
    their MessagePasser: GUIsMesgPasser() <- <%!GUI_threads_messagePasser%>
    void: invokeFunctionInThread(their MessagePasser: mesgPasser, their void: objToCall, their void: classToCall, their void: funcToCall, their void: arguments)
        <- <%!g_main_context_invoke(%1, GSourceFunc(%3_%4_CB), %5)%>
}

///////// Application areas
struct GLOBAL {
their GtkWidget: window

me void: activate(their GtkApplication: app, me gpointer: user_data) <- <%{
    GtkWidget *topBox;
    getMetrics();
    window = gtk_application_window_new (app);
    const gchar* titleStr = thisApp.gui->title.data();
    gtk_window_set_title (GTK_WINDOW (window), titleStr);
    gtk_window_set_default_size (GTK_WINDOW (window), 1000, 700);
    g_signal_connect (window, "destroy", G_CALLBACK (close_window), NULL);
    gtk_container_set_border_width (GTK_CONTAINER (window), 0);

    topBox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
    gtk_container_add (GTK_CONTAINER (window), topBox);
    gtk_widget_show (topBox);
    ////////////////////  A d d  A p p l i c a t i o n   M e n u

    GtkWidget *boxForMenubar;
    GtkWidget *menubar;


    boxForMenubar = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_container_add (GTK_CONTAINER (topBox), boxForMenubar);
    gtk_widget_show (boxForMenubar);

    menubar = gtk_menu_bar_new ();
    gtk_box_pack_start(GTK_BOX(boxForMenubar), menubar, TRUE, TRUE, 0);
    gtk_widget_show (menubar);

    //thisApp.createAppMenu(menubar);

      /////////////////////  A d d   A p p l i c a t i o n   I t e m s

    GtkWidget *frame;
    GtkWidget *appArea;

    frame = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_box_pack_start(GTK_BOX(topBox), frame, TRUE, TRUE, 0);

    //EventDispatcher.registerWidgetForEventDispatcher();
    thisApp.createAppArea(frame);


    /////////////////////  A d d  S t a t u s   A r e a



    gtk_widget_show_all (window);
}%>

}
