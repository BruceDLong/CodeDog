// Quic test
LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' LangVersion='GNU' optimize='speed';

Title = "Quic Protocol"
FileName = "Quic"
Version = "1.0"
CopyrightMesg = "Copyright 2020-2021 Bruce Long; All rights reserved."
Authors = "Bruce Long"
Description = "Quic Protocol"
ProgramOrLibrary = "program"

featuresNeeded = [Logger, Quic]

LicenseText = `All rights reserved.`

runCode = `
    logMgr.init(OFile)
    initCmdMgr()
    me string: clientOrServerMode <- CommandLineManager.getOption("QTest", "mode")
    me string: outFile <- CommandLineManager.getOption("QTest", "outFile")
    me string: ipAddr  <- CommandLineManager.getOption("QTest", "IPAddr")
    me string: port    <- CommandLineManager.getOption("QTest", "port")
    me ClientAndServer: clientAndServer;
    clientAndServer.runTest(clientOrServerMode, outFile, ipAddr, port)
`

do ManageCmdLine(cmd)

struct PingProtocol: inherits=QProtocol {
    void: init() <- {myStream.nextOpIsWrite()}
    me string: serverInit(me string: argsStr, their QuicStream: stream) <- {
        print("INIT SERVER: ",argsStr)
    }
    void: clientInit(me string: argsStr) <- {
        print("INIT SERVER: ",argsStr)
    }
    our QProtocol: createClone() <- {
        our PingProtocol:: retval
        retval <deep- self
        return(retval)
    }
    void: INIT() <- {
        protocolIDPrefix <- "codeDog/ping"
    }
    uint64: onServerRead(their QuicStream: qStream, their string: data, me bool: finished) <- {return(0)}
    bool: onServerWrite(their QuicStream: qStream) <- {return(false)}
    uint64: onClientRead(their QuicStream: qStream, their string: data, me bool: finished) <- {
        switch(step){
            case 0:{
                step <- 1
                myStream.nextOpIsWrite()
            }
            case 1:{}
        }
        return(false)
    }
    bool: onClientWrite(their QuicStream: qStream) <- {
        switch(step){
            case 0:{
                qStream.write(protocolIDPrefix+"\n")
                step <- 1
                myStream.nextOpIsRead()
            }
            case 1:{}
        }
        return(false)
    }
}

struct FetchFile: inherits=QProtocol {
    me string: fileName
    me FileStream: fileStream

    void: init() <- {}
    our QProtocol: createClone() <- {
        our FetchFile:: retval
        //retval <deep- self
        return(retval)
    }
    void: INIT() <- {
        protocolIDPrefix <- "FetchFile"
    }
    uint64: onServerRead(their QuicStream: qStream, their string: data, me bool: finished) <- {
        me uint64: streamID <- qStream.getStreamID()
        print("\nFETCH SERVER READ STEP:",step,"  STREAM_ID:",streamID,"\n")
        print("    DATA:",data,"\n")
        me uint64: bytesUsed <- 0
        switch(step){
        case 0:{
            step <- 1
            qStream.nextOpIsRead()
            }
        case 1:{
            bytesUsed <- qStream.readLine(data)
            if(qStream.readNotDone){return(bytesUsed)}
            qStream.nextOpIsWrite()
            qStream.doneReading()
            step <+- 1
            }
        }
        return(bytesUsed)
    }
    bool: onServerWrite(their QuicStream: qStream) <- {
        me uint64: streamID <- qStream.getStreamID()
        print("\nFETCH SERVER WRITE STEP:",step," fileName:", fileName,"  STREAM_ID:",streamID,"\n")
        if(streamID==0){
            switch(step){
            case 2:{
                me uint64: bytesUsed <- fileStream.read(qStream.buff)
                if(fileStream.failure()){print("ERROR: reading buff, fileName:'",fileName,"'\n")}
                qStream.write(qStream.buff.subStr(0, bytesUsed))
                print(qStream.buff.subStr(0, bytesUsed))
                return(false)
                }
            }
        }
        else{
            me uint64: bytesUsed <- fileStream.read(qStream.buff)
            if(fileStream.failure()){print("ERROR: reading buff, file:'",fileName,"'\n")}
            qStream.write(qStream.buff.subStr(0, bytesUsed))
            print(qStream.buff.subStr(0, bytesUsed))
            if(fileStream.EOF()){
                fileStream.close()
                qStream.close()
                step <+- 1
            }
            return(false)
        }
        return(false)
    }
    uint64: onClientRead(their QuicStream: qStream, their string: data, me bool: finished)<- {
        me uint64: streamID <- qStream.getStreamID()
        me uint64: bytesUsed
        print("\nFETCH CLIENT READ STEP:",step,"  STREAM_ID:",streamID,"\n")
        if(streamID==0){
            switch(step){
            case 1:{
                print(data)
                qStream.readBuffer <+- data
                bytesUsed <- data.size()
                if(finished and bytesUsed == data.size()){step <+- 1}
                }
            }
        }
        else{
            print(data)
            qStream.readBuffer <+- data
            bytesUsed <- data.size()
            if(finished and bytesUsed == data.size()){step <+- 1}
        }
        return(bytesUsed)
    }
    bool: onClientWrite(their QuicStream: qStream) <- {
        me uint64: streamID <- qStream.getStreamID()
        print("\nFETCH CLIENT WRITE STEP:",step,"  STREAM_ID:",streamID,"\n")
        switch(step){
        case 0:{
            print("SENDING TASK:",taskDescription,"\n")
            qStream.write(taskDescription)
            qStream.nextOpIsWrite()
            step <+- 1
            return(true)
            }
        }
        return(false)
    }
    void: onNewStream_CB(their QuicStream: qStream) <- {
        me uint64: streamID <- qStream.getStreamID()
        print("\n!!!!!!!!!!!!!!!!FetchFile::onNewStream_CB STREAM_ID:",streamID,"\n")
        // needs to call protocol.client.start which calls want read
    }
    me string: serverInit(me string: argsStr, their QuicStream: qStream) <- {
        print("INIT SERVER: ",argsStr,"\n")
        fileName <- argsStr
        fileStream.open(fileName)
        if(fileStream.failure()){
            print("ERROR: opening file:'",fileName,"'\n")
            return("ERR:"+taskID+":ERROR opening file:'",fileName)
        }
        qStream.myConnection.createNewStream()
        return("OK:"+taskID)
    }
    void: clientInit(me string: argsStr) <- {
        protocolArgs <- argsStr
        taskID       <- protocolIDPrefix+toString(lastTaskID)
        lastTaskID   <+- 1
        taskDescription <- protocolIDPrefix+":"+taskID+":"+protocolArgs
    }
}

struct ClientAndServer{
    void: runTest(me string: clientOrServer, me string: outFile, me string:ipAddr, me string: portNum) <- {
        our PingProtocol::  pingProtocol

        if(clientOrServer=="server"){
            me QuicEngine_Server: server
            our FetchFile::    fetchFile
            server.init("SFile", true, ipAddr, stoi(portNum))
            server.addProtocol(pingProtocol)
            server.addProtocol(fetchFile)
            server.start()
            eventLoopThread.waitForExit()
        }else if(clientOrServer=="client"){
            me QuicEngine_Client: client
            client.init("CFile", false, ipAddr, stoi(portNum))
            their QuicConnection_Client: qConn <- client.makeClientConnection(ipAddr, portNum)
            qConn.createNewStream()

            our FetchFile::    fetchFile
            fetchFile.clientInit("test.txt")
            qConn.addProtocol(fetchFile)
            client.start()

            our FetchFile::    fetchFile2
            fetchFile2.clientInit("test2.txt")
            qConn.addProtocol(fetchFile2)
            client.start()

            eventLoopThread.waitForExit()
            print("CLIENT_RAN\n")
        }else{logFatalError("Invalid running mode:"+clientOrServer)}
    //BRUCE: REmember to lsquic_engine_destroy(quicMgr.engine);
    }
}

struct GLOBAL{
    void: initCmdMgr() <- {
        CommandLineManager.defineOption("QTest", "mode",    "-m", "--mode",    "client or server", "_REQIRED")
        CommandLineManager.defineOption("QTest", "outFile", "-o", "--outFile", "Output file",      "quicOut.log")
        CommandLineManager.defineOption("QTest", "IPAddr",  "-a", "--IPAddr",  "IP address",       "::1")
        CommandLineManager.defineOption("QTest", "port",    "-p", "--port",    "Port number",      "12345")
    }
}
