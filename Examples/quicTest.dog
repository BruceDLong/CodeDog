// Quic test
LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' LangVersion='GNU' optimize='speed';

Title = "Quic Protocol"
FileName = "Quic"
Version = "1.0"
CopyrightMesg = "Copyright 2020-2021 Bruce Long; All rights reserved."
Authors = "Bruce Long"
Description = "Quic Protocol"
ProgramOrLibrary = "program"

featuresNeeded = [Logger, Quic]

LicenseText = `All rights reserved.`

runCode = `
    logMgr.init(OFile)
    CommandLineManager.defineOption("QTest", "mode",    "-m", "--mode",    "client or server", "_REQIRED")
    CommandLineManager.defineOption("QTest", "inFile",  "-i", "--inFile",  "Input file",       "quicIn.txt")
    CommandLineManager.defineOption("QTest", "outFile", "-o", "--outFile", "Output file",      "quicOut.log")
    CommandLineManager.defineOption("QTest", "IPAddr",  "-a", "--IPAddr",  "IP address",       "::1")
    CommandLineManager.defineOption("QTest", "port",    "-p", "--port",    "Port number",      "12345")
    me string: clientOrServerMode <- CommandLineManager.getOption("QTest", "mode")
    me string: inFile  <- CommandLineManager.getOption("QTest", "inFile")
    me string: outFile <- CommandLineManager.getOption("QTest", "outFile")
    me string: IPAddr  <- CommandLineManager.getOption("QTest", "IPAddr")
    me string: port    <- CommandLineManager.getOption("QTest", "port")
    me ClientAndServer: clientAndServer;
    clientAndServer.runTest(clientOrServerMode, inFile, outFile, IPAddr, port)
`

do ManageCmdLine(cmd)

struct PingProtocol: inherits=QProtocol {
    me bool: doStep() <- {return(true)}
    our QProtocol: createClone() <- {
        our PingProtocol:: retval
        retval <deep- self
        return(retval)
    }
    void: INIT() <- {
        protocolIDPrefix <- "slip/ping"
    }
    bool: onServerRead(their QuicStream: h) <- {}
    bool: onServerWrite(their QuicStream: h) <- {}
    bool: onClientRead(their QuicStream: h) <- {
        switch(step){
            case 0:{}
            case 1:{}
        }
        return(false)
    }
    bool: onClientWrite(their QuicStream: h) <- {
        switch(step){
            case 0:{h.write(protocolIDPrefix+"\n")}
            case 1:{}
        }
        //h.requestRead()
        return(false)
    }
}
struct FetchFile: inherits=QProtocol {
    me string: fileName

    me bool: doStep() <- {return(true)}
    our QProtocol: createClone() <- {
        our FetchFile:: retval
        retval <deep- self
        return(retval)
    }
    void: INIT() <- {
        protocolIDPrefix <- "FetchFile"
    }
    bool: onServerRead(their QuicStream: h) <- {
        // gets file name, opens file,  reads into a buffer
    }
    bool: onServerWrite(their QuicStream: h) <- {
        //sends back bytes read
    }
    bool: onClientRead(their QuicStream: h) <- {
        // receives bytes read, if not EOF, want write
    }
    bool: onClientWrite(their QuicStream: h) <- {
        // sends fileName to server
        print("\nonClientWrite FILE:", fileName)
        //qStream.requestRead()
        return(false)
    }
}


struct ClientAndServer{
    void: runTest(me string: clientOrServer, me string: inFile, me string: outFile, me string:IPAddr, me string: portNum) <- {
        our PingProtocol::  pingProtocol
        our FetchFile::    fetchFile

        if(clientOrServer=="server"){
            me QuicEngine_Server: server
            server.init("SFile", true, IPAddr, stoi(portNum))
            server.addProtocol(pingProtocol)
            server.addProtocol(fetchFile)
            server.run()
        } else if(clientOrServer=="client"){
            me QuicEngine_Client: client
            fetchFile.fileName <- inFile
            client.init("CFile", false, IPAddr, stoi(portNum))
            client.addProtocol(fetchFile)
            client.run()
        } else {logFatalError("Invalid running mode:"+clientOrServer)}
    //BRUCE: REmember to lsquic_engine_destroy(quicMgr.engine);
    }
}
