// Quic test
LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' LangVersion='GNU' optimize='speed';

Title = "Quic Protocol"
FileName = "Quic"
Version = "1.0"
CopyrightMesg = "Copyright 2020-2021 Bruce Long; All rights reserved."
Authors = "Bruce Long"
Description = "Quic Protocol"
ProgramOrLibrary = "program"

featuresNeeded = [Logger, Quic]

LicenseText = `All rights reserved.`

runCode = `
    logMgr.init(OFile)
    me string: clientOrServerMode <- CommandLineManager.getOption("QTest", "mode")
    me string: inFile  <- CommandLineManager.getOption("QTest", "inFile")
    me string: outFile <- CommandLineManager.getOption("QTest", "outFile")
    me string: IPAddr  <- CommandLineManager.getOption("QTest", "IPAddr")
    me string: port    <- CommandLineManager.getOption("QTest", "port")
    me ClientAndServer: clientAndServer;
    clientAndServer.runTest(clientOrServerMode, inFile, outFile, IPAddr, port)
`

do ManageCmdLine(cmd)

struct PingProtocol: inherits=QProtocol {
    me bool: doStep() <- {return(true)}
    void: init() <- {myStream.nextOpIsWrite()}
    our QProtocol: createClone() <- {
        our PingProtocol:: retval
        retval <deep- self
        return(retval)
    }
    void: INIT() <- {
        protocolIDPrefix <- "codeDog/ping"
    }
    uint64: onServerRead(their QuicStream: qStream, their string: data, me bool: finished) <- {}
    bool: onServerWrite(their QuicStream: qStream) <- {}
    uint64: onClientRead(their QuicStream: qStream, their string: data, me bool: finished) <- {
        switch(step){
            case 0:{}
            case 1:{}
        }
        return(false)
    }
    bool: onClientWrite(their QuicStream: qStream) <- {
        switch(step){
            case 0:{qStream.write(protocolIDPrefix+"\n")}
            case 1:{}
        }
        //qStream.requestRead()
        return(false)
    }
}
struct FetchFile: inherits=QProtocol {
    me string: fileName

    me bool: doStep() <- {return(true)}
    void: init() <- {myStream.nextOpIsRead()}
    our QProtocol: createClone() <- {
        our FetchFile:: retval
        retval <deep- self
        return(retval)
    }
    void: INIT() <- {
        protocolIDPrefix <- "FetchFile"
    }
    uint64: onServerRead(their QuicStream: qStream, their string: data, me bool: finished) <- {
        print("\nFETCH SERVER READ:",step,"\n")
        me uint64: bytesUsed
        switch(step){
        case 1:{
            bytesUsed <- qStream.readLine(data)
            if(qStream.readNotDone){return(bytesUsed)}
            qStream.nextOpIsWrite()
            fileName <- qStream.readBuffer
            step <+- 1
            }
        }
        return(bytesUsed)
    }
    bool: onServerWrite(their QuicStream: qStream) <- {
        print("\nFETCH SERVER WRITE STEP:",step,"\n")
        switch(step){
        case 2:{
            me FileStream: fileStream
            fileStream.open(fileName)
            while(!fileStream.EOF()){ //read from file then write to stream
                me uint64: bytesUsed <- fileStream.read(qStream.buff)
                //if(fileStream.failure()){print("ERROR: reading buff, fileName:'",fileName,"'\n")}
                qStream.write(qStream.buff.subStr(0, bytesUsed))
            }
            fileStream.close()
            qStream.close()
            step <+- 1
            return(false)
            }
        }
    }
    uint64: onClientRead(their QuicStream: qStream, their string: data, me bool: finished)<- {
        print("\nFETCH CLIENT READ STEP:",step,"\n")
        me uint64: bytesUsed
        switch(step){
        case 2:{
            qStream.readBuff <+- data
            bytesUsed <- data.size()
            step <+- 1
            //if(finished){print("READ BUFF:\n",qStream.readBuff)}
            }
        }
        return(bytesUsed)
    }
    bool: onClientWrite(their QuicStream: qStream) <- {
        print("\nFETCH CLIENT WRITE STEP:",step,"\n")
        switch(step){
        case 0:{
            qStream.write(protocolIDPrefix+"\n")
            qStream.nextOpIsWrite()
            step <+- 1
            return(true)
            }
        case 1:{
            qStream.write("test.txt\n")
            qStream.nextOpIsRead()
            step <+- 1
            return(false)
            }
        }
        return(false)
    }
}


struct ClientAndServer{
    void: runTest(me string: clientOrServer, me string: inFile, me string: outFile, me string:IPAddr, me string: portNum) <- {
        our PingProtocol::  pingProtocol
        our FetchFile::    fetchFile

        if(clientOrServer=="server"){
            me QuicEngine_Server: server
            server.init("SFile", true, IPAddr, stoi(portNum))
            server.addProtocol(pingProtocol)
            server.addProtocol(fetchFile)
            server.run()
        } else if(clientOrServer=="client"){
            me QuicEngine_Client: client
            fetchFile.fileName <- inFile
            client.init("CFile", false, IPAddr, stoi(portNum))
            client.addProtocol(fetchFile)
            client.run()
        } else {logFatalError("Invalid running mode:"+clientOrServer)}
    //BRUCE: REmember to lsquic_engine_destroy(quicMgr.engine);
    }
}

struct GLOBAL{
    void: initCmdMgr() <- {
        CommandLineManager.defineOption("QTest", "mode",    "-m", "--mode",    "client or server", "_REQIRED")
        CommandLineManager.defineOption("QTest", "inFile",  "-i", "--inFile",  "Input file",       "quicIn.txt")
        CommandLineManager.defineOption("QTest", "outFile", "-o", "--outFile", "Output file",      "quicOut.log")
        CommandLineManager.defineOption("QTest", "IPAddr",  "-a", "--IPAddr",  "IP address",       "::1")
        CommandLineManager.defineOption("QTest", "port",    "-p", "--port",    "Port number",      "12345")
    }
}
